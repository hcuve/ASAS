---
title: "Paper_analyses"
author: "Helio"
date: "22/07/2021"
output: html_document
---


Code for the paper: Valence modulated “subjective-objective” arousal

data<- last opened

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



Participants section

```{r}

library(readr)
library(tidyverse)
db_345_355_stim$Group<- if_else(as.numeric(db_345_355_stim$ssid)<500,"NT", "ASD")
# even though it says no pratice I actually kept the pratice
db_full4new_stim_screen_pupil_nopract$tNo

db_345_355 <- read_csv("tmp.df4_sum_full_bio_hr_self_parsed_345_356.csv")
View(db_345_355)

colnames(db_345_355)
db_345_355<- db_345_355 %>%
  rename(Gender = gender)%>%
  rename(menalHealth = mental_health)

# db_345_355_1<- select(db_345_355, c(1:41, )
colnames(db_full4new_stim_screen_pupil_nopract)



db_345_355_stim<- subset(db_345_355, db_345_355$screencontent == "stim")

# behavioural data
db_345_355
db_f


db_full4new_stim_screen_pupil_nopract$ssid<- as.character(db_full4new_stim_screen_pupil_nopract$ssid)
db_345_355_stim$ssid<- as.character(db_345_355_stim$ssid)
db_345_355_stim$tNo<- as.character(db_345_355_stim$tNo)


colnames(db_full4new_stim_screen_pupil_nopract)
colnames(db_345_355_stim)

install.packages("gtools")
?gtools::smartbind()




# binf only common columns

outersect <- function(x, y) {
  sort(c(setdiff(x, y),
         setdiff(y, x)))
}

common_cols 

oposite_columns<- outersect(colnames(db_full4new_stim_screen_pupil_nopract), colnames(db_345_355_stim$age_response_specific))

common_cols
oposite_columns
rbind(
  db_full4new_stim_screen_pupil_nopract[common_cols], 
  db_345_355_stim[common_cols]
)

colnames(db_full4new_stim_screen_pupil_nopract)
colnames(db_345_355_stim)

db_full4new_stim_screen_pupil_nopract
db_345_355_stim$gender_response

db_345_355_stim<- db_345_355_stim %>% 
  rename(Age = age_response_specific)%>%
  rename(Gender = gender_response)
db_345_355_stim$Age<- age_response_specific



db_full4new_stim_screen_pupil_nopract<- bind_rows(db_full4new_stim_screen_pupil_nopract, db_345_355_stim)


db_full4new_stim_screen_pupil_nopract %>%
  subset(Group == "NT")%>%
  group_by(ssid)%>%
  mutate(cor = cor(arousal, pup_basCor, use = "complete"))%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ungroup()%>%
  ggplot(aes(TAS, cor))+
  geom_point(aes(color = ssid))+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()

db_full4new_stim_screen_pupil_nopract_backup$Mean_HR
table(is.na(db_full4new_stim_screen_pupil_nopract$Mean_HR))

db_full4new_stim_screen_pupil_nopract$Mean_HR %>%
  subset(Group == "NT")%>%
  subset(ssid_num>304)%>%
  subset(ssid!= "344")%>%
  subset(ssid!= "900")%>%
  group_by(ssid)%>%
  mutate(BIO_CDA.AmpSum_z = scale(BIO_CDA.AmpSum, center = TRUE, scale = TRUE)[,1])%>%
  mutate(cor = cor(arousal, pup_basCor, use = "complete"))%>%
  mutate(cor2 = cor(arousal, BIO_CDA.AmpSum_z, use = "complete"))%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ungroup()%>%
  ggplot(aes(TAS, Mean_HR))+
  geom_point(aes(color = ssid))+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()

```



```{r}
unique(db_full4new_stim_screen_pupil_nopract$Group)



db_full4new_stim_screen_pupil_nopract$Group_t<- NULL

unique(db_full4new_stim_screen_pupil_nopract$Group_t)                                                     

# db_full4new_stim_screen_pupil_nopract$grou

# db_full4new_stim_screen_pupil_nopract$Gender<- substr(db_full4new_stim_screen_pupil_nopract$Gender, 1,1)

db_full4new_stim_screen_pupil_nopract_update<- bind_rows(db_full4new_stim_screen_pupil_nopract,
                                                         db_345_355_stim)

db_full4new_stim_screen_pupil_nopract_update$Group<- if_else(as.numeric(db_full4new_stim_screen_pupil_nopract_update$ssid) < 500, "NT",                                               if_else(as.numeric(db_full4new_stim_screen_pupil_nopract_update$ssid) > 700,"NT", "ASD"))


participants_demog <- db_full4new_stim_screen_pupil_nopract_update %>%
  subset(Group == "NT")%>%
  group_by(ssid, Gender)%>%
  summarise_at(c("Age","WASIM", "TAS", "AQ", "IAS", "DASSTotal"), mean, na.rm = TRUE)


unique(participants_demog$ssid)
table(participants_demog$Gender)
colnames(participants_demog)
summary(participants_demog$Age)
sd(participants_demog$Age, na.rm = TRUE)
# table(is.na(participants_demog$Age))
```



Pupil changes and subjective arousal and valence ratings


# let's model it formally
  
# remember baseline corection is equivalendt to stimuli intercept
 
```{r} 
pupil_arousal_findings<- list()
library(lmerTest)
db_345_355_stim$stim
View(db_full4new_stim_screen_pupil_nopract)
unique(db_full4new_stim_screen_pupil_nopract$trialUnq)
db_full4new_stim_screen_pupil_nopract$ssid
unique(db_full4new_stim_screen_pupil_nopract$trialUnq.x)

db_full4new_stim_screen_pupil_nopract_backup<- db_full4new_stim_screen_pupil_nopract

db_full4new_stim_screen_pupil_nopract <- db_full4new_stim_screen_pupil_nopract_update

# db_full4new_stim_screen_pupil_nopract$stimIAPS<- subs
unique(db_full4new_stim_screen_pupil_nopract$stimIAPS)
unique(db_full4new_stim_screen_pupil_nopract_backup$stimIAPS)
unique(substr(db_full4new_stim_screen_pupil_nopract_backup$stimIAPS, 1,8))


db_full4new_stim_screen_pupil_nopract$stimIAPS[db_full4new_stim_screen_pupil_nopract$stimIAPS== "2900.1.jpg"]<- "2900.jpg1.jpg"

db_full4new_stim_screen_pupil_nopract$stimIAPS[db_full4new_stim_screen_pupil_nopract$stimIAPS== "2345.1.jpg"]<- "2345.jpg1.jpg"

unique(db_full4new_stim_screen_pupil_nopract$stimIAPS)
unique(db_full4new_stim_screen_pupil_nopract_backup$stimIAPS)

db_full4new_stim_screen_pupil_nopract$Label<- substr(db_full4new_stim_screen_pupil_nopract$stimIAPS, 1,8)
unique(db_full4new_stim_screen_pupil_nopract$Label)
table(is.na(db_full4new_stim_screen_pupil_nopract$stimIAPS))

table(is.na(db_full4new_stim_screen_pupil_nopract$Label))
unique(imageJ_IAPS$Label)

imageJ_IAPS_names<- colnames(imageJ_IAPS)
imageJ_IAPS_names<- imageJ_IAPS_names[3:14]
imageJ_IAPS_names
db_full4new_stim_screen_pupil_nopract
db_full4new_stim_screen_pupil_nopract_test <- dplyr::left_join(db_full4new_stim_screen_pupil_nopract, imageJ_IAPS, by = "Label")

table(is.na(db_full4new_stim_screen_pupil_nopract_test$Mean.y))

db_full4new_stim_screen_pupil_nopract<- db_full4new_stim_screen_pupil_nopract[,!(names(db_full4new_stim_screen_pupil_nopract) %in% imageJ_IAPS_names)]



db_full4new_stim_screen_pupil_nopract$Mean_gray_z<- NULL

# megre IAPS data

db_full4new_stim_screen_pupil_nopract <- left_join(db_full4new_stim_screen_pupil_nopract, imageJ_IAPS, by = "Label")

table(is.na(db_full4new_stim_screen_pupil_nopract$Mean))
# test<- subset(db_full4new_stim_screen_pupil_nopract, is.na(Mean))
nrow(db_full4new_stim_screen_pupil_nopract)
# rows = 2858

unique(db_full4new_stim_screen_pupil_nopract$ssid)

db_full4new_stim_screen_pupil_nopract$Mean_gray_z<- scale(db_full4new_stim_screen_pupil_nopract$Mean, center = TRUE, scale = TRUE)[,1]


db_full4new_stim_screen_pupil_nopract$ssid_num <- as.numeric(as.character(db_full4new_stim_screen_pupil_nopract$ssid))


```


lmer pupil

```{r}
db_full4new$screencontent_no
db_full4new %>%
  subset(screencontent_no ==4)%>%
  group_by(ssid)%>%
  summarise_if(is.numeric, mean,na.rm = TRUE)%>%
  ggplot(aes(TAS, fix_count))+
  geom_point()+
  geom_smooth(method = lm, se = F)+
  ggpubr::stat_cor()



db_full4new %>%
  subset(screencontent_no > 2)%>%
  group_by(ssid)%>%
  summarise_if(is.numeric, mean,na.rm = TRUE)%>%
  ggplot(aes(TAS, fix_count))+
  geom_point()+
  geom_smooth(method = lm, se = F)+
  ggpubr::stat_cor()

```


```{r}

options(contrasts = c("contr.sum","contr.poly"))
options(scipen = 999)

table(is.na(db_full4new_stim_screen_pupil_nopract$arousal))
table(is.na(db_full4new_stim_screen_pupil_nopract$ArousalMean))
table(is.na(db_full4new_stim_screen_pupil_nopract$Group))

db_full4new_stim_screen_pupil_nopract<- db_full4new_stim_screen_pupil_nopract%>%
  ungroup()%>%
  mutate(arousal_c = scale(arousal, center = TRUE, scale = TRUE)[,1],
         valence_c = scale(valence, center = TRUE, scale = TRUE)[,1])

pupil_arousal_findings$pupil_from_arousal <- lmer(pup_basCor ~ arousal_c*Mean_gray_z  +(1 +Mean_gray_z | ssid) + (0+arousal_c| ssid), REML = FALSE,
                      data = subset(db_full4new_stim_screen_pupil_nopract, 
                                    # pupil_outlier == FALSE & 
                                     Group == "NT"
                                    # arousal_outler == FALSE
                                    ))

summary(pupil_arousal_findings$pupil_from_arousal)
# singularity (drop arousal c slope)

# is there a correlation between mean arousal rating and meang, gray(

db_full4new_stim_screen_pupil_nopract%>%
  group_by(stimIAPS,ground_valence_lab) %>%
  summarise_at(c('arousal_c', 'Mean_gray_z'), mean, na.rm = TRUE)%>%
  ggplot(aes(arousal_c, Mean_gray_z, color = ground_valence_lab))+
  geom_point()+
  ggpubr::stat_cor()


db_full4new_stim_screen_pupil_nopract %>%
  subset(ssid_num<500)%>%
  group_by(ssid)%>%
  mutate(cor_ar_vl = cor(arousal, valence, use = "complete"))%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ssid,cor_ar_vl))+
  geom_point()+
  geom_hline(yintercept = -.75)+
  geom_hline(yintercept = -.90)
  geom_histogram()

  db_full4new_stim_screen_pupil_nopract$screencontent
  
  table(is.na(  db_full4new_stim_screen_pupil_nopract$pup_basCor ))
  unique(  db_full4new_stim_screen_pupil_nopract$ssid)
  
  db_full4new_stim_screen_pupil_nopract %>%
    # subset(ssid_num < 343)%>%
  # subset(Group == "NT")%>%
  group_by(ssid)%>%
  mutate(cor_ar_pup = cor(arousal, pup_basCor, use = "complete"))%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(TAS,cor_ar_pup))+
  geom_point()+
    geom_smooth(method = lm, se = F)+
    ggpubr::stat_cor()
  geom_hline(yintercept = -.75)+
  geom_hline(yintercept = -.90)
  
  
  
  
  



```


# Valence and arousal - ridge
```{r}

db_full4new_stim_screen_pupil_nopract$ssid<- as.factor(as.character(db_full4new_stim_screen_pupil_nopract$ssid))


db_full4new_stim_screen_pupil_nopract$arousal_outler
db_full4new_stim_screen_pupil_nopract$pupil_outlier

# flag potential outliers

db_full4new_stim_screen_pupil_nopract<- db_full4new_stim_screen_pupil_nopract %>%
  group_by(stimIAPS) %>%
  mutate(arousal_outler = if_else(arousal > (median(arousal, na.rm = TRUE) + 
                                               (4*mad(arousal, na.rm = TRUE))), TRUE,
         if_else(arousal < (median(arousal, na.rm = TRUE) - 
                              (4*mad(arousal, na.rm = TRUE))), TRUE, FALSE)))%>%
  group_by(ssid)%>%
   mutate(pupil_outlier = if_else(pup_basCor > (median(pup_basCor, na.rm = TRUE) 
                                                + (3*mad(pup_basCor, na.rm = TRUE))), TRUE,
         if_else(pup_basCor < (median(pup_basCor, na.rm = TRUE) - 
                                 (3*mad(pup_basCor, na.rm = TRUE))), TRUE, FALSE)))


# fit pupil response froma rousal and valence

table(is.na(db_full4new_stim_screen_pupil_nopract$valence_c))
pupil_arousal_findings$pupil_from_ar_vale <- lmer(pup_basCor ~ (valence_c* arousal_c) +
                                                    Mean_gray_z  +
                                                    (1 + Mean_gray_z | ssid)+
                                                    (0+ valence_c | ssid),
                                                  REML = FALSE,
                      data = db_full4new_stim_screen_pupil_nopract%>%
                         subset(Group == "NT")%>%
                        subset(pupil_outlier == FALSE)%>%
                        subset(arousal_outler == FALSE))





# fit pupil response froma arousal slope

table(is.na(db_full4new_stim_screen_pupil_nopract$valence_c))
library(lmerTest)
library(tidyverse)
pupil_arousal_findings$pupil_from_ar_slope_vale <- lmer(pup_basCor ~ (valence_c* arousal_c) +
                                                    Mean_gray_z  +
                                                    (1  | ssid)+
                                                    (0+ arousal_c | ssid),
                                                  REML = FALSE,
                      data = db_full4new_stim_screen_pupil_nopract%>%
                         subset(Group == "NT")%>%
                        subset(pupil_outlier == FALSE)%>%
                        subset(arousal_outler == FALSE))


summary(pupil_arousal_findings$pupil_from_ar_slope_vale)


# unique(db_full4new_stim_screen_pupil_nopract$tNo)
# 
# unique(db_full4new_stim_screen_pupil_nopract$ssid)

relgrad <- with(pupil_arousal_findings$pupil_from_ar_vale@optinfo$derivs,solve(Hessian,gradient))
max(abs(relgrad)) #0.0002044252

summary(pupil_arousal_findings$pupil_from_ar_vale)
plot(pupil_arousal_findings$pupil_from_ar_vale)

car::vif(pupil_arousal_findings$pupil_from_ar_vale) #curoff 4
# valence_c           arousal_c         Mean_gray_z valence_c:arousal_c 
#            1.876902            1.801054            1.004734            1.080785

summary(pupil_arousal_findings$pupil_from_ar_vale)
plots_paper$interaction_ar_vl <- interactions::interact_plot(pupil_arousal_findings$pupil_from_ar_vale , pred = arousal_c, modx = valence_c)

plots_paper$interaction_ar_vl 
interactions::interact_plot(pupil_arousal_findings$pupil_from_ar_val_gaze , pred = valence_c , modx = arousal_c)




# export model table
library(MuMIn)
library(sjmisc)
sjPlot::tab_model(pupil_arousal_findings$pupil_from_ar_vale)

table(is.na(db_full4new_stim_screen_pupil_nopract$Group))

table(db_full4new_stim_screen_pupil_nopract$Group)

# unique(db_full4new_stim_screen_pupil_nopract$ssid)
plots_paper$pupil_correlation <- db_full4new_stim_screen_pupil_nopract %>%
   subset(Group == "NT")%>%
  subset(pupil_outlier == FALSE)%>%
  subset( arousal_outler == FALSE & !is.na(Alexithymia))%>%
  subset(!is.na(Alexithymia))%>%
  # subset(ssid_num<500)%>%
    # group_by(ssid,Alexithymia, is_valence_high)%>%
   group_by(ssid,Alexithymia, mediansplit_sample_valence2,mediansplit_sample_arousal2)%>%
    mutate(cortest = cor(arousal_c, pup_basCor, use = "complete"))%>%
    summarise_if(is.numeric, mean, na.rm = TRUE)%>%
        ggplot(aes(mediansplit_sample_valence2, cortest, color = mediansplit_sample_valence2))+
           geom_bar(stat="summary", fun.y = "mean", alpha = .4)+
  
    geom_jitter(width = .1, alpha = .1)+
        stat_summary( geom = 'pointrange')+
          stat_summary(aes(group = ssid), geom = 'line', color = "black", alpha = .1)+
    ylab("R pupil vs self report arousal")+
  theme_classic()+
  geom_hline(yintercept = 0, linetype = 'dashed', alpha = .2)+
   # ggpubr::stat_compare_means(paired = TRUE)+
  ggpubr::stat_compare_means()
  # facet_grid(~mediansplit_sample_arousal2)

  
  plots_paper$pupil_correlation+ p$graphstyle
  
  
summary(lmer(pup_basCor ~ (valence_c) +
                                                    Mean_gray_z  +
                                                    (1 + Mean_gray_z | ssid)+
                                                    (0+ valence_c | ssid),
                                                  REML = FALSE,
                      data = db_full4new_stim_screen_pupil_nopract%>%
                         subset(Group == "NT")%>%
                        subset(pupil_outlier == FALSE)%>%
                        subset(arousal_outler == FALSE)))

summary(lmer(pup_basCor ~ (arousal_c) +
                                                    Mean_gray_z  +
                                                    (1 + Mean_gray_z | ssid)+
                                                    (0+ valence_c | ssid),
                                                  REML = FALSE,
                      data = db_full4new_stim_screen_pupil_nopract%>%
                         subset(Group == "NT")%>%
                        subset(pupil_outlier == FALSE)%>%
                        subset(arousal_outler == FALSE)))


summary(lmer(pup_basCor ~ (arousal_c+valence_c)
                                                      +
                                                    (1 + Mean_gray_z | ssid)+
                                                    (0+ valence_c | ssid),
                                                  REML = FALSE,
                      data = db_full4new_stim_screen_pupil_nopract%>%
                         subset(Group == "NT")%>%
                        subset(pupil_outlier == FALSE)%>%
                        subset(arousal_outler == FALSE)))


macthed_test$stimIAPS2<- as.character(macthed_test$stimIAPS2)
test_matchedM<- left_join( macthed_test, db_full4new_stim_screen_pupil_nopract,by = "stimIAPS2")

matchedPupiltest <- lmer(pup_basCor ~ (arousal_c*valence_c)
                                                      +
                                                    (1 + Mean_gray_z | ssid)+
                                                    (0+ valence_c | ssid),
                                                  REML = FALSE,
                      data = test_matchedM%>%
                         subset(Group == "NT"))

matchedPupiltest

interactions::interact_plot(matchedPupiltest , pred =arousal_c  , modx =  valence_c)

```


swicth predictirs

```{r}
unique(db_full4new_stim_screen_pupil_nopract$ssid)

library(lmerTest)
pupil_arousal_findings$ar_from_val_pup <- lmer(arousal_c ~ valence_c*pup_basCor +
                                                    Mean_gray_z  +
                                                    (1 | ssid)+
                                                    (1|stimIAPS),
                                                  REML = FALSE,
                      data = db_full4new_stim_screen_pupil_nopract%>%
                        subset(Group == "NT"))
                        # subset(pupil_outlier == FALSE)%>%
                        # subset(arousal_outler == FALSE))

summary(pupil_arousal_findings$ar_from_val_pup)

interactions::interact_plot(pupil_arousal_findings$ar_from_val_pup, pred = valence_c, modx =  pup_basCor)

```


```{r eval=FALSE, include=FALSE}
# lassomodels$firt

ridgemodels<-list()

# ridge
unique(db_new$exp)
# "3b" "3b"
db_full4new_stim_screen_pupil_nopract
unique(db_new$exp)

db_new_exp3b<- subset(db_full4new_stim_screen_pupil_nopract, 
                                     ssid_num< 500)

pp_id_3b<- unique(db_new_exp3b$ssid)

db_new_exp3b$ar_x_val<- db_new_exp3b$arousal_c* db_new_exp3b$valence_c

db_new_exp3b_1 <- select(db_new_exp3b, c(ssid, arousal_c, valence_c, ar_x_val, Mean_gray_z,pup_basCor))
i = 10
?glmnet::cv.glmnet
set.seed(808)

cv_fits_3b<- list(list())
cv_fits<-list(list())
library(glmnet)

for (i in pp_id_3b) {
  temp_3b <- subset(db_new_exp3b_1, ssid == 304)
  # cv_fits <- list(i)
  cv_fits_3b[[i]]<- list(cv.glmnet(as.matrix(temp_3b[,2:5]),temp_3b$pup_basCor, 
                                alpha = 0, nfolds = 8))
  
  cv_fits[[i]]<- list(glmnet(as.matrix(temp_3b[,2:5]),temp_3b$pup_basCor,
                             family = "gaussian",
                             alpha = 0, lambda = cv_fits_3b[[i]][[1]]$lambda.min))
  }

coef(cv_fits_3b[[i]][[1]], s = cv_fits_3b[[i]][[1]]$lambda.min)

coef(cv_fits[[i]][[1]], s = cv_fits[[i]][[1]]$lambda)
# 5 x 1 sparse Matrix of class "dgCMatrix"
#                       1
# (Intercept)  0.57036534
# arousal_c    0.34759064
# valence_c    0.34825059
# ar_x_val    -0.03044521
# Mean_gray_z -0.22724284

my_vector_ar<- vector(mode="numeric")
i

plot(cv_fits[["306"]][[1]])

plot(cv_fits[[2]][[1]])
plot(cv_fits[[2]][[1]],xvar="lambda",label=TRUE)
fit3=glmnet(x,g4,family="multinomial")
plot(cv_fits[[2]][[1]],pch=19)

View(my_vectors)
for (i in pp_id_3b) {
my_vector_ar[i]<- coef(cv_fits[[i]][[1]], s = cv_fits[[i]][[1]]$lambda)[2] # 3 is gender sd
}

my_vector_vl<- vector(mode="numeric")
# non gender sd
for (i in pp_id_3b) {
my_vector_vl[i]<- coef(cv_fits[[i]][[1]], s = cv_fits[[i]][[1]]$lambda)[3] 
}

# status
my_vector_ar_vl<- vector(mode="numeric")

for (i in pp_id_3b) {
my_vector_ar_vl[i]<- coef(cv_fits[[i]][[1]], s = cv_fits[[i]][[1]]$lambda)[4] 
}

# physical
my_vector_gray<- vector(mode="numeric")

for (i in pp_id_3b) {
my_vector_gray[i]<- coef(cv_fits[[i]][[1]], s = cv_fits[[i]][[1]]$lambda)[5] 
}



t.test(my_vector_ar)
# t = 41.071, df = 42, p-value < 0.00000000000000022
t.test(my_vector_vl)
# t = 34.501, df = 42, p-value < 0.00000000000000022

t.test(my_vector_ar_vl)
# t = -16.486, df = 42, p-value < 0.00000000000000022

t.test(my_vector_gray)
# t = -62.057, df = 42, p-value < 0.00000000000000022
```


same analyses as above but regress brightness out of pupil

```{r}

pupil_arousal_findings$pupil_from_brightness <- lmer(pup_basCor ~ 
                                                    Mean_gray_z  +
                                                    (1  | ssid),
                                                    # (0+ valence_c* arousal_c | ssid),
                                                  REML = FALSE,
                      data = subset(db_full4new_stim_screen_pupil_nopract, 
                                    # pupil_outlier == FALSE & ssid_num< 500 & 
                                      # arousal_outler == FALSE
                                    ))

pupil_arousal_findings$pupil_from_brightness_lm <- lm(pup_basCor ~ 
                                                    Mean,
                                                    
                      data = db_full4new_stim_screen_pupil_nopract, na.action=na.exclude) 


summary(pupil_arousal_findings$pupil_from_brightness)

plot(pupil_arousal_findings$pupil_from_brightness)

# store residuals
db_full4new_stim_screen_pupil_nopract$pup_resid <- resid(pupil_arousal_findings$pupil_from_brightness)
?resid
db_full4new_stim_screen_pupil_nopract$pup_resid_lm <- resid(pupil_arousal_findings$pupil_from_brightness_lm,
                                                            na.action=na.exclude)


db_full4new_stim_screen_pupil_nopract%>%
  ggplot(aes(pup_resid, Mean_gray_z))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()

# no correlated with IV - good


db_full4new_stim_screen_pupil_nopract%>%
  ggplot(aes(pup_resid, pup_basCor))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()

# strong correlation, in this case this is good, because it means there is a large amount of unexplained variance not acconted for by the predictor


# predict pupil residuals
pupil_arousal_findings$pupil_resid_from_ar_vale <- lmer(pup_resid_lm ~ (arousal_c*valence_c) +
                                                    
                                                    (1+arousal_c*valence_c  | ssid),
                                                    # (0+ valence_c* arousal_c | ssid),
                                                  REML = FALSE,
                      data = subset(db_full4new_stim_screen_pupil_nopract, 
                                    pupil_outlier == FALSE &
                                    ssid_num< 500 
                                    &
                                      arousal_outler == FALSE
                                      )) # results hold with or withouth outliers 


summary(pupil_arousal_findings$pupil_resid_from_ar_vale)

# using residuals from lmer create a singularity as they eliminate individual participants variability, this is solved by using residuals from lm

plots_paper<- list()
plots_paper$interaction_ar_vl <- interactions::interact_plot(pupil_arousal_findings$pupil_from_ar_vale, pred = arousal_c, modx = valence_c)

interactions::interact_plot(pupil_arousal_findings$pupil_resid_from_ar_vale , pred = valence_c , modx = arousal_c)

plots_paper$interaction_ar_vl+p$graphstyle

plots_paper$interaction_ar_vl


db_full4new_stim_screen_pupil_nopract_nt<- subset(db_full4new_stim_screen_pupil_nopract, Group == "NT")

db_full4new_stim_screen_pupil_nopract_nt%>%
  group_by(stimIAPS)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(arousal_c, valence_c))+
  geom_point()+
  ggpubr::stat_cor()

cor.test(db_full4new_stim_screen_pupil_nopract_nt$valence, db_full4new_stim_screen_pupil_nopract_nt$arousal_c)
car::scatter3d(db_full4new_stim_screen_pupil_nopract_nt$arousal_c, 
          db_full4new_stim_screen_pupil_nopract_nt$pup_basCor, 
          db_full4new_stim_screen_pupil_nopract_nt$valence_c,
          fit = "smooth"
          # point = FALSE,
          
          # surface = FALSE,
          # point.col = ""
          )
```


quick check of TAS

```{r}
unique(db_full4new_stim_screen_pupil_nopract$ssid)

db_full4new_stim_screen_pupil_nopract$TASc<- scale(db_full4new_stim_screen_pupil_nopract$TAS, center = TRUE, scale = TRUE)[,1]

db_full4new_stim_screen_pupil_nopract<- db_full4new_stim_screen_pupil_nopract%>%
  ungroup()%>%
  mutate(arousal_c = scale(arousal, center = TRUE, scale = TRUE)[,1],
         valence_c = scale(valence, center = TRUE, scale = TRUE)[,1])



db_full4new_stim_screen_pupil_nopract$valence_abs<- abs(db_full4new_stim_screen_pupil_nopract$valence)
db_full4new_stim_screen_pupil_nopract$valence_abs_c<- scale(db_full4new_stim_screen_pupil_nopract$valence_abs, center = TRUE,scale = TRUE)[,1]

pupil_arousal_findings$pupil_from_ar_vale_TAS <- lmer(pup_basCor ~ (valence_c* arousal_c)*TASc +
                                                    Mean_gray_z  +
                                                    (1 + Mean_gray_z | ssid)+
                                                    (0+ arousal_c | ssid),
                                                  REML = FALSE,
                      data = db_full4new_stim_screen_pupil_nopract%>%
                         subset(Group == "NT"))
                        subset(pupil_outlier == FALSE)%>%
                        subset(arousal_outler == FALSE))

summary(pupil_arousal_findings$pupil_from_ar_vale_TAS)

interactions::interact_plot(pupil_arousal_findings$pupil_from_ar_vale_TAS, pred = TASc, modx = arousal_c)
interactions::interact_plot(pupil_arousal_findings$pupil_from_ar_vale_TAS, pred = TASc, modx = arousal_c, mod2= valence_c)

# abs
pupil_arousal_findings$pupil_from_vale__tas_abs <- lmer(pup_basCor ~ valence_abs_c* TASc +
                                                    Mean_gray_z  +
                                                    (1 + Mean_gray_z | ssid)+
                                                    (0+ arousal_c | ssid),
                                                  REML = FALSE,
                      data = db_full4new_stim_screen_pupil_nopract%>%
                         subset(Group == "NT"))



db_full4new_stim_screen_pupil_nopract$arousal_abs<- abs(db_full4new_stim_screen_pupil_nopract$arousal)
db_full4new_stim_screen_pupil_nopract$arousal_abs_c<- scale(db_full4new_stim_screen_pupil_nopract$arousal_abs, center = TRUE,scale = TRUE)[,1]

pupil_arousal_findings$pupil_from_ar__tas_abs <- lmer(pup_basCor ~ arousal_abs_c* TASc +
                                                    Mean_gray_z  +
                                                    (1 + Mean_gray_z | ssid)+
                                                    (0+ arousal_c | ssid),
                                                  REML = FALSE,
                      data = db_full4new_stim_screen_pupil_nopract%>%
                         subset(Group == "NT"))

summary(pupil_arousal_findings$pupil_from_ar__tas_abs)

cor.test(db_full4new_stim_screen_pupil_nopract$valence_abs_c, abs(db_full4new_stim_screen_pupil_nopract$arousal))
```

interaction plot

```{r}
sf = 1 # scaling factor to make it easier to change sizes of everything, in which case change here

p$graphstyle_int <-  theme(#base plot theme
  
  # axis lines
  axis.line.y = element_line(color="black", size = 1.5),
  axis.line.x = element_line(color="black", size = 1,5),
  
  axis.title.y=element_text(size = 16*(sf+.5), margin=margin(0,5,0,0)),
  axis.title.x=element_text(size = 16*(sf+.5), margin=margin(0,5,0,0)),
  
  # text
  strip.text.x = element_text(size = 12*(sf+.5),  colour = "black"),
  strip.text.y = element_text(size = 12*(sf+.5),  colour = "black"),
  
  text=element_text(size = 14, family = "sans"),
  axis.text.x = element_text(size = 14*(sf+.5), family = "sans", colour = "black",),
  axis.text.y = element_text(size = 14*(sf+.5), family = "sans", colour = "black"),
  
  
  # panel
  panel.grid.major = element_blank(),
  panel.background = element_blank(),
  # panel.background = element_rect(fill="transparent"),
  # panel.border = element_rect(fill="transparent"),
  # strip shades (reco rectagles)
   # strip.background = element_blank(),
  
  # legend
  legend.position = "top",
  legend.key = element_rect(colour = "transparent", fill="transparent"),
  #legend.direction = "horizontal",

  legend.text = element_text(size = 10*(sf+.3)),
  # legend.title = element_text(size = 10*(sf+.3)),
  # legend line tends to be really small in print so adjust here
  legend.key.height = unit(.5, "cm"),
  legend.key.width = unit(2, "cm"),
  
  #legend.text = element_text(size = 10*sf),
  # legend.title=element_blank(),
  #legend.text = element_blank(),
  #axis.ticks = element_blank(),
)


plots_paper$interaction_ar_vl<- plots_paper$interaction_ar_vl +
  theme_classic()+
  p$graphstyle_int+
  xlab("Arousal (z)")+
  ylab("Pupil change (z)")+
  scale_y_continuous(breaks = c(-1,0,1))

plots_paper$interaction_ar_vl<- plots_paper$interaction_ar_vl+   scale_y_continuous(breaks = c(-2,-1,0,1), limits = c(-2,1))

 plots_paper$interaction_ar_vl +
   theme_classic()+
   p$graphstyle_int
   


plots_paper[["interaction_ar_vl"]][["data"]]%>%
  ggplot(aes(arousal_c, pup_basCor, linetype = modx_group))+
  stat_summary(aes(color = valence_c), geom = 'line', size = 2)+
  p$graphstyle_int
```




Predict arousal from pupil


```{r}
# with arousal as DV
pupil_arousal_findings$arousal_from_pup <- lmer(arousal ~ valence_c*pup_basCor  + 
                                                  (1| stimIAPS)+
                                                 # (1 | stimIAPS)+
                                                  (1  | ssid),
                                                REML = FALSE,
                      data = db_full4new_stim_screen_pupil_nopract%>%
                         subset(Group == "NT")%>%
                        subset(pupil_outlier == FALSE)%>%
                        subset(arousal_outler == FALSE))
summary(pupil_arousal_findings$arousal_from_pup)

anova(pupil_arousal_findings$arousal_from_pup)

# expected correlation between valence and pupil is low



interactions::interact_plot(pupil_arousal_findings$arousal_from_pup , pred = valence_c, modx = pup_basCor)

interactions::interact_plot(pupil_arousal_findings$arousal_from_pup, pred =pup_basCor , modx =  valence_c) #better 
# same pattern
# pupil is more aligned with subjective arousal in the more positive trials



# flip dv to valence

pupil_arousal_findings$valence_from_pup <- lmer(valence ~ arousal_c*pup_basCor  + (1| stimIAPS)+
                                                 # (1 | ssid),
                                                  (0 +arousal_c | ssid),
                                                REML = FALSE,
                      data = subset(db_full4new_stim_screen_pupil_nopract, 
                                    Group == "NT"))
summary(pupil_arousal_findings$valence_from_pup)
anova(pupil_arousal_findings$valence_from_pup)

# so it's not the case that pupil is tracking valence
# it's the case that arousal pupil relation is modulated by valence, and this is true regardless of whether we use a maximal or minimal model

interactions::interact_plot(pupil_arousal_findings$valence_from_pup , pred = valence_c, modx = pup_basCor)

interactions::interact_plot(pupil_arousal_findings$valence_from_pup, pred =pup_basCor , modx =  arousal_c)

test<- subset(db_full4new_stim_screen_pupil_nopract, 
                                    Group == "NT")

cor.test(test$arousal_c, test$valence_c)
?rmcorr::rmcorr
plot(rmcorr::rmcorr(participant = "stimIAPS2", measure1 = "arousal_c", measure2 = "valence_c", data = test))


plot(rmcorr::rmcorr(participant = "ssid", measure1 = "arousal_c", measure2 = "valence_c", data = test))


db_full4new_stim_screen_pupil_nopract%>%
  ggplot(aes(arousal_c, valence_c))+
  geom_point()


# pollu
db_full4new_stim_screen_pupil_nopract$valence_c_sq<- db_full4new_stim_screen_pupil_nopract$valence**2
polyyrelation <- lmer(arousal_c ~ valence_c+valence_c_sq+ (1|ssid) + (1|stimIAPS),
                     REML = FALSE,
                     data = db_full4new_stim_screen_pupil_nopract)

summary(polyyrelation)


polyyrelation1 <- lmer(arousal_c ~ valence_c + (1|ssid) + (1|stimIAPS),
                     REML = FALSE,
                     data = db_full4new_stim_screen_pupil_nopract)


polyyrelation3 <- lmer(arousal_c ~ valence_c_sq+ (1|ssid) + (1|stimIAPS),
                     REML = FALSE,
                     data = subset(db_full4new_stim_screen_pupil_nopract ))

summary(polyyrelation)
summary(polyyrelation)

MuMIn::r.squaredGLMM(polyyrelation)
MuMIn::r.squaredGLMM(polyyrelation1)
MuMIn::r.squaredGLMM(polyyrelation3)


anova(polyyrelation3, polyyrelation, polyyrelation1)

db_full4new_stim_screen_pupil_nopract%>%
  subset(Group == "NT")%>%
  mutate(ssid= as.numeric(ssid))%>%
  subset(ssid = 20)%>%
  ggplot(aes(valence_c, arousal_c, color = ssid))+
  geom_point()+
  stat_ellipse()+
  stat_smooth()

```


Timecourse analyses

# prepare timecourse data
```{r prepare timecourse data}
rm(justone_test, lucy_plots, test)

nrow(tmp.df4_full_stim_downs_jun2021)

# import the timecourse

nrow(tmp.df4_full_stim_downs_jun2021)
tmp.df4_full_stim_downs_jun2021 <- readRDS("~/OneDrive - Nexus365/InteroStudy2020/analysis/DataAnalysisJanuary2020/DataAnalysisJan2020/tmp.df4_full_stim_downs_jun2021.rds")


unique(tmp.df4_full_stim_downs_jun2021$timebin)
# new folks 
library(readr)

tmp_df4_timeseries_345_356 <- read_csv("tmp.df4_timeseries_345_356.csv")

unique(tmp_df4_timeseries_345_356$ssid)
View(tmp_df4_timeseries_345_356)

colnames(tmp.df4_full_stim_downs_jun2021)
colnames(tmp_df4_timeseries_345_356)
# downsample to 60 bins


# create bins
# install.packages("OneR")
# install.packages("OneR")
library(OneR)

?bin
unique(tmp_df4_timeseries_345_356$screencontent)
tmp_df4_timeseries_345_356_stim <- subset(tmp_df4_timeseries_345_356, tmp_df4_timeseries_345_356$screencontent == "stim")

tmp_df4_timeseries_345_356_stim$timebin <- OneR::bin(tmp_df4_timeseries_345_356_stim$timerezero3, nbin = 60)



# dowsample by averaging?
colnames(tmp_df4_timeseries_345_356_stim)


tmp_df4_timeseries_345_356_stim_downs <- tmp_df4_timeseries_345_356_stim %>%
  group_by(ssid, tNo, timebin, trial,trialUnq)%>%
  summarise_at(c('timerezero3','pup_basCor', 'gaze_x_cor_pix', 'gaze_y_cor_pix'), 
               mean, na.rm = TRUE)

?saveRDS
saveRDS(tmp_df4_timeseries_345_356_stim_downs, "tmp_df4_timeseries_345_356_stim_downs.rds")


# merge pupil series with behavioural data
colnames(db_full4new_stim_screen_pupil_nopract)
cname_db_full4new_stim_subset<- colnames(db_full4new_stim_subset)

db_full4new_stim_subset_backup<-db_full4new_stim_subset

# db_full4new_stim_subset<- db_full4new_stim_screen_pupil_nopract[,c(1:4,6:7,12:13,16,21:27, 31:56,80:81,84:96,98:114,116:124)]
db_full4new_stim_subset<- db_full4new_stim_screen_pupil_nopract[,c(cname_db_full4new_stim_subset)]

View(db_full4new_stim_subset)

```

# match types of merging variables (this is 30-hz)

```{r}

unique(tmp.df4_full_stim_downs_jun2021_with_beh2$timebin2)


unique(tmp.df4_full_stim_downs_jun2021_with_behnew$timebin2)
tmp.df4_full_stim_downs_jun2021_with_beh2$ssid<- as.character(tmp.df4_full_stim_downs_jun2021_with_beh2$ssid)
db_full4new_stim_subset$ssid<- as.character(db_full4new_stim_subset$ssid)

# tNo
tmp.df4_full_stim_downs_jun2021_with_beh2$tNo <- as.character(tmp.df4_full_stim_downs_jun2021_with_beh2$tNo)

db_full4new_stim_subset$tNo <- as.character(db_full4new_stim_subset$tNo)
# unique(db_full4new_stim_subset$tNo)
# unique(tmp.df4_full_stim_downs_jun2021_with_beh2$tNo)

# merge
nrow(tmp.df4_full_stim_downs_jun2021_with_beh2)
# 87529

table(is.na(db_full4new_stim_subset$mediansplit_self_valence))

tmp.df4_full_stim_downs_jun2021_with_beh2$tNo<- as.numeric(tmp.df4_full_stim_downs_jun2021_with_beh2$tNo)

tmp.df4_full_stim_downs_jun2021_with_beh2<- tmp.df4_full_stim_downs_jun2021_with_beh2%>%
  arrange(ssid,tNo, timerezero3)

tmp.df4_full_stim_downs_jun2021_with_beh <- left_join(tmp.df4_full_stim_downs_jun2021_with_beh2, db_full4new_stim_subset)


```


# higher sample dataset

```{r}
library(ggplot2)
library(tidyverse)
install.packages("gazer")
library(gazer)

# temp backup

tmp.df4_full_stim_downs_jun2021
tmp.df4_full_stim_downs_jun2021_backup<- tmp.df4_full_stim_downs_jun2021

unique(tmp.df4_full_stim_downs_jun2021$timebin)

tmp_df4_timeseries_345_356_stim_downs_backup<- tmp_df4_timeseries_345_356_stim_downs

tmp_df4_timeseries_345_356_stim_downs$ssid<- as.character(tmp_df4_timeseries_345_356_stim_downs$ssid)

tmp_df4_timeseries_345_356_stim_downs$tNo<- as.character(tmp_df4_timeseries_345_356_stim_downs$tNo)

unique(tmp.df4_full_stim_downs_jun2021$timebin)
unique(tmp_df4_timeseries_345_356_stim_downs$timebin)

tmp.df4_full_stim_downs_jun2021$ssid<- as.character(tmp.df4_full_stim_downs_jun2021$ssid)
tmp.df4_full_stim_downs_jun2021$tNo<- as.character(tmp.df4_full_stim_downs_jun2021$tNo)
# bind old and new data
# nrow(tmp.df4_full_stim_downs_jun2021)+ nrow(tmp_df4_timeseries_345_356_stim_downs) = 205703

tmp.df4_full_stim_downs_jun2021$tNo<- as.character(tmp.df4_full_stim_downs_jun2021$tNo)

tmp.df4_full_stim_downs_jun2021 <- bind_rows(tmp.df4_full_stim_downs_jun2021,tmp_df4_timeseries_345_356_stim_downs)

# tmp.df4_full_stim_downs_jun2021
table(is.na(tmp_df4_timeseries_345_356_stim_downs$pup_basCor))
# 355
table(is.na(tmp.df4_full_stim_downs_jun2021$pup_basCor))




# backup[]
tmp.df4_full_stim_downs_jun2021_60bins_backup2<- tmp.df4_full_stim_downs_jun2021_60bins

unique(db_full4new_stim_subset$ssid)


unique(tmp.df4_full_stim_downs_jun2021$ssid)
unique(db_full4new_stim_subset$ssid)

unique(tmp.df4_full_stim_downs_jun2021$tNo)
unique(db_full4new_stim_subset$tNo)

unique(tmp.df4_full_stim_downs_jun2021$trial)
unique(db_full4new_stim_subset$trial)


tmp.df4_full_stim_downs_jun2021_60bins 


table(is.na(db_full4new_stim_subset$arousal))



db_full4new_stim_subset
db_full4new_stim_subset$tNo<- as.character(db_full4new_stim_subset$tNo)


# try see if arranging things solve the issue
tmp.df4_full_stim_downs_jun2021<- tmp.df4_full_stim_downs_jun2021%>%
  arrange(ssid, tNo, timerezero3)

db_full4new_stim_subset<- db_full4new_stim_subset%>%
  arrange(ssid, tNo)

db_full4new_stim_subset_valis<- subset( db_full4new_stim_subset, gaze_valid_prop>.80)

tmp.df4_full_stim_downs_jun2021_.1 <- left_join(tmp.df4_full_stim_downs_jun2021, db_full4new_stim_subset$gaze_valid_prop, by = c("ssid", "tNo", "trial"))


table(is.na(db_full4new_stim_subset_valis$gaze_valid_prop))
tmp.df4_full_stim_downs_jun2021_.1 <- left_join(db_full4new_stim_subset_valis,tmp.df4_full_stim_downs_jun2021,  by = c("ssid", "tNo", "trial"))

table(is.na(tmp.df4_full_stim_downs_jun2021_.1$arousal))
nrow(tmp.df4_full_stim_downs_jun2021_.1)
nrow(tmp.df4_full_stim_downs_jun2021)

nrow(db_full4new_stim_subset)
nrow(test)
nrow(tmp.df4_full_stim_downs_jun2021_60bins)
unique(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)


View(db_full4new_stim_subset)
table(is.na(db_full4new_stim_subset$arousal))
table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$arousal))

table(is.na(test$arousal))
table(is.na(test$arousal))


test1<- subset(test, is.na(arousal))

test2<- subset(test, !is.na(arousal))
table(test2$ssid)

# create a dataframe version where we downsample to60 and not to 30

tmp.df4_full_stim_downs_jun2021_.1$Label<- substr(tmp.df4_full_stim_downs_jun2021_.1$stimIAPS, 1,8)

tmp.df4_full_stim_downs_jun2021_.1$Label2<- substr(tmp.df4_full_stim_downs_jun2021_.1$stimIAPS, 1,4)
imageJ_IAPS$Label2<- substr(imageJ_IAPS$Label, 1,4)

unique(imageJ_IAPS$Label2)
unique(tmp.df4_full_stim_downs_jun2021_.1$Label2)

# backup
tmp.df4_full_stim_downs_jun2021_60bins_backup<- tmp.df4_full_stim_downs_jun2021_.1

tmp.df4_full_stim_downs_jun2021_60bins<- left_join(tmp.df4_full_stim_downs_jun2021_.1, imageJ_IAPS, by = "Label2")


tmp.df4_full_stim_downs_jun2021_60bins$Mean_gray_z<- scale(tmp.df4_full_stim_downs_jun2021_60bins$Mean, center = TRUE, scale = TRUE)[,1]


nrow(tmp.df4_full_stim_downs_jun2021_60bins)
# 172168 good+
# 205703 (with new)

table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$valence))
table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$pup_basCor))

as.factor(tmp.df4_full_stim_downs_jun2021_60bins$timebin)
```


Quick check that things make sense
30 s timebins
```{r eval=FALSE, include=FALSE}
unique(tmp.df4_full_stim_downs_jun2021_with_beh$timebin2)
# group_by(stimIAPS)%>%


tmp.df4_full_stim_downs_jun2021_with_beh<- tmp.df4_full_stim_downs_jun2021_with_beh %>%
  ungroup()%>%
  mutate(mediansplit_sample_valence2 = 
           if_else(ValenceMeanThisSample >= 
                     median(ValenceMeanThisSample,
                            na.rm = TRUE), 
                   "More positive", "More negative"))%>%
  mutate(mediansplit_sample_arousal2 = if_else(ArousalMeanThisSample >=
                                                  median(ArousalMeanThisSample,
                                                         na.rm = TRUE), "High", "Low"))



# higher sample rate

tmp.df4_full_stim_downs_jun2021_60bins$mediansplit_sample_valence2

tmp.df4_full_stim_downs_jun2021_60bins<- tmp.df4_full_stim_downs_jun2021_60bins %>%
  ungroup()%>%
  mutate(mediansplit_sample_valence2 = 
           if_else(ValenceMeanThisSample > 
                     median(ValenceMeanThisSample,
                            na.rm = TRUE), 
                   "More positive", "More negative"))%>%
  mutate(mediansplit_sample_arousal2 = if_else(ArousalMeanThisSample >
                                                  median(ArousalMeanThisSample,
                                                         na.rm = TRUE), "High", "Low"))




tmp.df4_full_stim_downs_jun2021_with_beh %>%
  subset(!is.na(ground_arousal_lab))%>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  stat_smooth(aes(group= ground_arousal_lab, color = ground_arousal_lab), fun = mean,geom = "line",
               se = F, alpha = .1, size = 1.5)+
  stat_smooth(aes(group=ground_arousal_lab, color = ground_arousal_lab), size = 3)+  
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")+
  xlim(0,6)+
   facet_grid(~mediansplit_self_valence)


```



60 bins
```{r}


tmp.df4_full_stim_downs_jun2021_60bins<- tmp.df4_full_stim_downs_jun2021_60bins%>%
  ungroup()%>%
  mutate(mediansplit_ground_valence = if_else(ValenceMean >=
                                                  median(ValenceMean,
                                                         na.rm = TRUE), "More positive", "More negative"))%>%
  mutate(mediansplit_ground_arousal = if_else(ArousalMean >=
                                                  median(ArousalMean,
                                                         na.rm = TRUE), "High", "Low"))%>%
    mutate(mediansplit_sample_valence2 = if_else(arousal >=
                                                  median(arousal,
                                                         na.rm = TRUE), "More positive", "More negative"))%>%
  mutate(mediansplit_sample_arousal2 = if_else(valence >=
                                                  median(valence,
                                                         na.rm = TRUE), "High", "Low"))

table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$timebin))
ground_arousal_lab

tmp.df4_full_stim_downs_jun2021_60bins_no_na<- subset(tmp.df4_full_stim_downs_jun2021_60bins, !is.na(stimDescription))
nrow(tmp.df4_full_stim_downs_jun2021_60bins_no_na)

nrow(tmp.df4_full_stim_downs_jun2021_60bins)


tmp.df4_full_stim_downs_jun2021_60bins_no_na$stimIAPS2<- substr(tmp.df4_full_stim_downs_jun2021_60bins_no_na$stimIAPS, 1,4)

left_join(tmp.df4_full_stim_downs_jun2021_60bins_no_na, cluster_stim)%>%
# tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(!is.na(ground_arousal_lab))%>%
  ggplot(aes(x = timerezero3, y = pup_basCor,color = mediansplit_ground_arousal, linetype = mediansplit_ground_valence))+
  
 # stat_summary(aes(group= mediansplit_ground_arousal, color = mediansplit_ground_arousal, linetype = mediansplit_ground_valence), fun = mean,geom = "line", size = 1.5)
 #  
  # stat_smooth(aes(group= mediansplit_ground_arousal), fun = mean,geom = "line",
  #              se = F, alpha = 1, size = 1.5)+
  stat_smooth(size=1.5, method = "loess", level = 0.95, 
    fullrange = TRUE, se = FALSE) + 
  # stat_smooth(aes(group=mediansplit_ground_arousal, color = mediansplit_ground_arousal), size = 3)+  
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")+
  xlim(0,6)+
   labs(color  = "mediansplit_ground_arousal", linetype = "mediansplit_ground_valence")
   facet_grid(~mediansplit_ground_valence)
   
   
tmp.df4_full_stim_downs_jun2021_60bins_no_na<- left_join(tmp.df4_full_stim_downs_jun2021_60bins_no_na, cluster_stim)
# plot with clusters
# left_join(tmp.df4_full_stim_downs_jun2021_60bins_no_na, cluster_stim)%>%
# tmp.df4_full_stim_downs_jun2021_60bins %>%
  # subset(!is.na(ground_arousal_lab))%>%
tmp.df4_full_stim_downs_jun2021_60bins_no_na%>%
  ggplot(aes(x = timerezero3, y = pup_basCor,color = cluster_interpreted, linetype = cluster_interpreted))+
  
 # stat_summary(aes(group= mediansplit_ground_arousal, color = mediansplit_ground_arousal, linetype = mediansplit_ground_valence), fun = mean,geom = "line", size = 1.5)
 #  
  # stat_smooth(aes(group= mediansplit_ground_arousal), fun = mean,geom = "line",
  #              se = F, alpha = 1, size = 1.5)+
  stat_smooth(size=1.5, method = "loess", level = 0.95, 
    fullrange = TRUE, se = FALSE) + 
  # stat_smooth(aes(group=mediansplit_ground_arousal, color = mediansplit_ground_arousal), size = 3)+  
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")+
  xlim(0,6)
   labs(color  = "mediansplit_ground_arousal", linetype = "mediansplit_ground_valence")
   # facet_grid(~mediansplit_ground_valence)
   
   
   
```




```{r}

tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(!is.na(ground_arousal_lab))%>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  stat_smooth(aes(group= mediansplit_sample_arousal2, color = mediansplit_sample_arousal2), fun = mean,geom = "line",
               se = F, alpha = .1, size = 1.5)+
  stat_smooth(aes(group=mediansplit_sample_arousal2, color = mediansplit_sample_arousal2), size = 3)+  
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")+
  xlim(0,6)+
   facet_grid(~mediansplit_sample_valence2)



tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(!is.na(ground_arousal_lab))%>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  stat_smooth(aes(group= mediansplit_sample_valence2, color = mediansplit_sample_valence2), fun = mean,geom = "line",
               se = F, alpha = .1, size = 1.5)+
  stat_smooth(aes(group=, color = mediansplit_sample_valence2), size = 3)+  
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")+
  xlim(0,6)+
   facet_grid(~ mediansplit_sample_arousal2)


# what causes 
tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(!is.na(ground_arousal_lab))%>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  stat_smooth(aes(group= mediansplit_sample_valence2, color = mediansplit_sample_valence2), fun = mean,geom = "line",
               se = F, alpha = .1, size = 1.5)+
  stat_smooth(aes(group=, color = mediansplit_sample_valence2), size = 3)+  
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")+
  xlim(0,6)
   facet_grid(~ mediansplit_sample_arousal2)
   
   
   tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(!is.na(ground_arousal_lab))%>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  stat_smooth(aes(color = mediansplit_sample_arousal2), fun = mean,geom = "line",
               se = F, alpha = .1, size = 1.5)+
  stat_smooth(aes(group=stimIAPS, color = mediansplit_sample_arousal2), size = .6, se = F)+
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
     # geom_text(aes(label = ssid))+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")+
  xlim(0,6)+
     geom_text(aes(label = stimIAPS))
   facet_grid(~ mediansplit_sample_valence2)
   
tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(!is.na(ground_arousal_lab))%>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  # stat_smooth(aes(color = mediansplit_ground_arousal), fun = mean,geom = "line",
  #              se = F, alpha = .1, size = 1.5)+
  stat_smooth(aes(group=stimIAPS, color = ground_arousal_lab), size = .6, se = F)+
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
     # geom_text(aes(label = ssid))+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")+
  xlim(0,6)+
     # geom_text(aes(label = stimIAPS))+
   facet_grid(~ ground_valence_lab)



```

check baselining onto specific valences
```{r Scrap this}

# - use IAPS data to split valence - positive negative
# - within that - compute arousal low mid high within each valence both for the iaps data and my study
# do this on a participant basis or sampleÇ? try sample first
tmp.df4_full_stim_downs_jun2021_60bins %>%
  ungroup()%>%
  group_by(ground_valence_lab)%>%
  mutate(ArousalMean_z_by_val = scale(ArousalMean, center = TRUE, scale = TRUE)[,1])%>%
   mutate(Arousal_z_by_val = scale(arousal, center = TRUE, scale = TRUE)[,1])%>%
  group_by(stimIAPS,ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  # ggplot(aes(ground_valence_lab, ArousalMean_z_by_val ))+
  ggplot(aes(ground_valence_lab, Arousal_z_by_val ))+
  # geom_point()+
  stat_summary(geom = 'pointrange')

# hpw does this relate to the original ratigs

# do this on a participant basis or sampleÇ? try sample first
tmp.df4_full_stim_downs_jun2021_60bins %>%
  ungroup()%>%
  group_by(ground_valence_lab)%>%
  mutate(ArousalMean_z_by_val = scale(ArousalMean, center = TRUE, scale = TRUE)[,1])%>%
   mutate(Arousal_z_by_val = scale(arousal, center = TRUE, scale = TRUE)[,1])%>%
  # group_by(stimIAPS,ground_valence_lab)%>%
  # summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  # ggplot(aes(ground_valence_lab, ArousalMean_z_by_val ))+
  ggplot(aes(ValenceMean, ArousalMean_z_by_val ))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  # geom_smooth(aes(group = ground_valence_lab), method = 'lm', se = F)
  # stat_summary(geom = 'pointrange')+
      ggpubr::stat_cor()


tmp.df4_full_stim_downs_jun2021_60bins %>%
  ungroup()%>%
  group_by(ground_valence_lab)%>%
  mutate(ArousalMean_z_by_val = scale(ArousalMean, center = TRUE, scale = TRUE)[,1])%>%
   mutate(Arousal_z_by_val = scale(arousal, center = TRUE, scale = TRUE)[,1])%>%
  group_by(stimIAPS,ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  # ggplot(aes(ground_valence_lab, ArousalMean_z_by_val ))+
  ggplot(aes(Arousal_z_by_val, valence_c))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  # geom_smooth(aes(group = ground_valence_lab), method = 'lm', se = F)
  # stat_summary(geom = 'pointrange')+
      ggpubr::stat_cor()




?cut
tmp.df4_full_stim_downs_jun2021_60bins$valence_self<- cut(tmp.df4_full_stim_downs_jun2021_60bins$valence, 3,
                                                          labels = c("Negative", "Neutral", "Positive"))


tmp.df4_full_stim_downs_jun2021_60bins %>%
  ungroup()%>%
  group_by(ground_valence_lab)%>%
  # mutate(ArousalMean_z_by_val = scale(ArousalMean, center = TRUE, scale = TRUE)[,1])%>%
   mutate(Arousal_z_by_val = scale(arousal, center = TRUE, scale = TRUE)[,1])%>%
  group_by(stimIAPS,ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  # ggplot(aes(ground_valence_lab, ArousalMean_z_by_val ))+
  ggplot(aes(ground_valence_lab, Arousal_z_by_val))+
  geom_point()+
  # geom_smooth(aes(group = ground_valence_lab), method = 'lm', se = F)
  stat_summary(geom = 'pointrange')+
      ggpubr::stat_cor()

  
  # mean center within neutral positive, neutral negative


tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos<- if_else(tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab!= "More negative", TRUE, FALSE)

tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg <- if_else(tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab!= "More positive", TRUE, FALSE)

tmp.df4_full_stim_downs_jun2021_60bins <- tmp.df4_full_stim_downs_jun2021_60bins%>%
  group_by(neutral_pos)%>%
  mutate(neutral_pos_mean_arousal = mean(ArousalMean, na.rm = TRUE),
                                         neutral_pos_sd_arousal = sd(ArousalMean, na.rm = TRUE))%>%
  mutate(neutral_pos_mean_arousal_self = mean(arousal, na.rm = TRUE),
         neutral_pos_sd_arousal_self = sd(arousal, na.rm = TRUE))%>%
  group_by(neutral_neg)%>%
  
  mutate(neutral_neg_mean_arousal = mean(ArousalMean, na.rm = TRUE),
                                         neutral_neg_sd_arousal = sd(ArousalMean, na.rm = TRUE)) %>%
  mutate(neutral_neg_mean_arousal_self = mean(arousal, na.rm = TRUE),
         neutral_neg_sd_arousal_self = sd(arousal, na.rm = TRUE))
  
# group_by()

# replace the values when neutral_pos and neutral_neg is FALSE respectivelly
# library(dplyr)
# check how many nas do we have before we start
table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg_mean_arousal))
 # FALSE   TRUE 
# 158193  13975 


# compute new variables where arousal is scaled to negative (negative value - mean of negative and neutral) same to positive
tmp.df4_full_stim_downs_jun2021_60bins <- tmp.df4_full_stim_downs_jun2021_60bins %>%
    mutate_at(vars(matches('^neutral_pos_.*$')), ~ 
                  replace(., neutral_pos == FALSE, NA))
  
table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos_mean_arousal))
table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos_sd_arousal_self))

table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg_mean_arousal_self))


tmp.df4_full_stim_downs_jun2021_60bins <- tmp.df4_full_stim_downs_jun2021_60bins %>%
    mutate_at(vars(matches('^neutral_neg_.*$')), ~ 
                  replace(., neutral_neg == FALSE, NA))

table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg_sd_arousal_self))


tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos_mean_arousal <- if_else(tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos == TRUE, tmp.df4_full_stim_downs_jun2021_60bins)
  

colnames(tmp.df4_full_stim_downs_jun2021_60bins)


tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground <- ifelse(tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos == TRUE & 
                                                                      tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab == "More positive", tmp.df4_full_stim_downs_jun2021_60bins$ArousalMean - tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos_mean_arousal,
                                                                    ifelse(tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab == "More negative" & tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg == TRUE, tmp.df4_full_stim_downs_jun2021_60bins$ArousalMean - 
                                                                             tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg_mean_arousal, 
                                                                           tmp.df4_full_stim_downs_jun2021_60bins$ArousalMean - mean(tmp.df4_full_stim_downs_jun2021_60bins$ArousalMean, na.rm = TRUE)))


# same with self report

tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_self <- ifelse(tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos == TRUE & 
                                                                      tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab == "More positive", tmp.df4_full_stim_downs_jun2021_60bins$arousal - tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos_mean_arousal_self,
                                                                    ifelse(tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab == "More negative" & tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg == TRUE, tmp.df4_full_stim_downs_jun2021_60bins$arousal - 
                                                                             tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg_mean_arousal_self, 
                                                                           tmp.df4_full_stim_downs_jun2021_60bins$arousal - mean(tmp.df4_full_stim_downs_jun2021_60bins$arousal, na.rm = TRUE)))


# visualise new ground and self report arousal baseline separetelly for positive and negative valenced stimuli (based on IAPS validation)
table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground))
  
table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground), tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab)

library(tidyverse)

tmp.df4_full_stim_downs_jun2021_60bins%>%
  group_by(stimIAPS, ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ground_valence_lab, ArousalMean))+
  geom_point()+
  stat_summary(geom = 'pointrange')

tmp.df4_full_stim_downs_jun2021_60bins%>%
  group_by(stimIAPS, ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ground_valence_lab, arousal_rel_neutral_ground))+
  # geom_point()+
  stat_summary(geom = 'pointrange')


tmp.df4_full_stim_downs_jun2021_60bins%>%
  group_by(stimIAPS, ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ground_valence_lab, arousal_rel_neutral_self))+
  geom_point()+
  stat_summary(geom = 'pointrange')

arousal_rel_neutral_self

# ?cut
# is the cutoff for positive in the prevopis variable too large
tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_2<- cut(tmp.df4_full_stim_downs_jun2021_60bins$ValenceMean, c(0,4,5,9), 
                                                              labels = c("negative", "neutral", "positive"))

tmp.df4_full_stim_downs_jun2021_60bins%>%
  group_by(stimIAPS, ssid,ground_valence)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(stimIAPS, abs(arousal), color = ground_valence))+
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange')


tmp.df4_full_stim_downs_jun2021_60bins%>%
  group_by(stimIAPS, ssid,ground_valence)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ground_valence, abs(arousal), color = ground_valence))+
  geom_boxplot()+
  stat_summary(funy = mean, geom = 'pointrange')

tmp.df4_full_stim_downs_jun2021_60bins%>%
  subset(!is.na(ground_valence))%>%
  group_by(stimIAPS, ssid,ground_valence)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ground_valence, abs(arousal), color = ground_valence))+
  geom_boxplot()+
  stat_summary(funy = mean, geom = 'pointrange')

# absoluting 

tmp.df4_full_stim_downs_jun2021_60bins%>%
  subset(!is.na(ground_valence))%>%
  # group_by(ground_valence)%>%
  ungroup()%>%
  mutate(abs_arousal = abs(arousal), na.rm = TRUE)%>%
  mutate(abs_arousal_z = abs_arousal - mean(abs_arousal, na.rm = TRUE))%>%
  # summarise_at(c('mean_abs_arousal'), median, na.rm = TRUE)
  group_by(ssid,ground_valence_2)%>%
  summarise_if(is.numeric, median, na.rm = TRUE)%>%
  ggplot(aes(ground_valence_2, abs_arousal_z, color = ground_valence_2))+
  geom_point()+
  stat_summary(funy = median, geom = 'pointrange')+
  geom_boxplot()


absolutetest<- tmp.df4_full_stim_downs_jun2021_60bins%>%
  group_by(stimDescription,ground_valence_2)%>%
  # summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  mutate(arousal_abs = abs(arousal), valence_abs = abs(valence))%>%
  
  summarise_at(c("arousal", "ArousalMean", "ValenceMean","arousal_abs", "valence", "valence_abs", "arousal_abs_on_pos"), mean, na.rm = TRUE) 



absolutetest %>%
  ggplot(aes(ValenceMean,arousal_abs))+
  geom_point()+
  geom_text(aes(label = stimDescription))

absolutetest %>%
  ggplot(aes(ArousalMean,arousal_abs))+
  geom_point()+
  geom_text(aes(label = stimDescription))

# he U shape relationship seems to hold dependign on whether arousal is absolute - converting actovation to absolute

# absolute arousal don't correlate with iaps arousal
# we we taking valence absolute as intensity
absolutetest %>%
  ggplot(aes(ValenceMean,valence_abs))+
  geom_point()+
  geom_text(aes(label = stimDescription))

# arousal vs absolute valence
absolutetest %>%
  ggplot(aes(ArousalMean,valence_abs))+
  geom_point()+
  geom_text(aes(label = stimDescription))+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()
# it seems like arousal in our case is picking something that is not just intemnsity of vaence, as it correlates better with arousal Mean

absolutetest %>%
  ggplot(aes(valence,valence_abs))+
  geom_point()+
  geom_text(aes(label = stimDescription))+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()

# try and compute correlation using valencabs(

tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(!is.na(ground_valence_2))%>%
  group_by(ssid, stimIAPS,ground_valence_2)%>%
  
  mutate(arousal_abs = abs(arousal), valence_abs = abs(valence))%>%
  group_by(ssid, ground_valence_2)%>%
  mutate(cortest = cor(valence_abs, pup_basCor, use = "complete"))%>%
  
  # summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  # summarise_at(c("arousal", "ArousalMean","ValenceMean", "arousal_abs", "valence", "valence_abs", "arousal_abs_on_pos"), mean, na.rm = TRUE) %>%
  
  ggplot(aes(ground_valence_2, cortest, color = ground_valence_2))+
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange')
    theme(axis.text.x = element_text(angle = 60))
    
    



```

just positive check
```{r}
# Plot just positive
tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ground_valence_2 == "positive")%>%
  group_by(stimDescription,ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(stimDescription, arousal))+
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange', color = "blue")+
   stat_summary(aes( y = ArousalMean), funy = mean, geom = 'pointrange', color = "red")+
  theme(axis.text.x = element_text(angle = 60))


tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ground_valence_2 == "positive")%>%
  group_by(stimDescription,ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(stimDescription, arousal))+
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange', color = "blue")+
   stat_summary(aes( y = ArousalMean), funy = mean, geom = 'pointrange', color = "red")+
  theme(axis.text.x = element_text(angle = 60))

# if we removed the erotic ones would we have positive tracking arousal better


# negative
tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ground_valence_2 == "negative")%>%
  group_by(stimDescription,ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(stimDescription, arousal))+
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange', color = "blue")+
   stat_summary(aes( y = ArousalMean), funy = mean, geom = 'pointrange', color = "red")+
  theme(axis.text.x = element_text(angle = 60))


tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ground_valence_2 == "positive")%>%
  group_by(stimIAPS,ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ArousalMean, arousal))+
  geom_point()+
  geom_smooth(method = 'lm')+
  ggpubr::stat_cor()

tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ground_valence_2 == "negative")%>%
  group_by(stimIAPS,ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ArousalMean, arousal))+
  geom_point()+
  geom_smooth(method = 'lm')+
  ggpubr::stat_cor()


tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ground_valence_2 == "neutral")%>%
  group_by(stimIAPS,ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ArousalMean, arousal))+
  geom_point()+
  geom_smooth(method = 'lm')+
  ggpubr::stat_cor()
  
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange', color = "blue")+
   stat_summary(aes( y = ArousalMean), funy = mean, geom = 'pointrange', color = "red")+
  theme(axis.text.x = element_text(angle = 60))
  
  
  
  tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ground_valence_2 == "positive")%>%
  group_by(stimDescription,ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(stimDescription, arousal))+
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange', color = "blue")+
   stat_summary(aes( y = ArousalMean), funy = mean, geom = 'pointrange', color = "red")+
  theme(axis.text.x = element_text(angle = 60))
  

  tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ground_valence_2 != "negative")%>%
  group_by(stimDescription,ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(stimDescription, abs(arousal), color = ground_valence_2))+
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange')+
   # stat_summary(aes( y = ArousalMean), funy = mean, geom = 'pointrange')+
  theme(axis.text.x = element_text(angle = 60))
  
  
  tmp.df4_full_stim_downs_jun2021_60bins$arousal_abs_on_pos<- if_else(tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_2!= "negative", abs(tmp.df4_full_stim_downs_jun2021_60bins$arousal), tmp.df4_full_stim_downs_jun2021_60bins$arousal)
  
  
    tmp.df4_full_stim_downs_jun2021_60bins %>%
  # subset(ground_valence_2 != "negative")%>%
  group_by(stimDescription,ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ground_valence_2, arousal_abs_on_pos, color = ground_valence_2))+
  geom_point()+
  stat_summary(funy = mean, geom = 'pointrange')+
   # stat_summary(aes( y = ArousalMean), funy = mean, geom = 'pointrange')+
  theme(axis.text.x = element_text(angle = 60))
    
    
        tmp.df4_full_stim_downs_jun2021_60bins %>%
  # subset(ground_valence_2 != "negative")%>%
  group_by(stimDescription,ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ground_valence_2, abs(arousal), color = ground_valence_2))+
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange')+
   # stat_summary(aes( y = ArousalMean), funy = mean, geom = 'pointrange')+
  theme(axis.text.x = element_text(angle = 60))
  
```

erotica check
```{r}
# if we removed the erotic ones would we have positive tracking arousal better?
  
  
  # organise pupil by growing order of positivearousal
  tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ground_valence_2 == "positive")%>%
  group_by(stimIAPS,stimDescription, ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
    arrange(arousal)%>%
  ggplot(aes(arousal, pup_basCor))+
    geom_text(aes(label = stimDescription))+
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange', color = "blue")+
    xlim(-7,-2)+
    ggpubr::stat_cor()
   stat_summary(aes( y = ArousalMean), funy = mean, geom = 'pointrange', color = "red")+
  theme(axis.text.x = element_text(angle = 60))
   
   # so arousal (ativation) sis till being tracked even if we exclude the sexual stimuli
   
   
   
     tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ground_valence_2 == "negative")%>%
  group_by(stimIAPS,stimDescription, ground_valence_2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
    arrange(arousal)%>%
  ggplot(aes(arousal, pup_basCor))+
    geom_text(aes(label = stimDescription))+
  # geom_point()+
  stat_summary(funy = mean, geom = 'pointrange', color = "blue")+
    # xlim(-7,-2)+
    ggpubr::stat_cor()

# if we removed the erotic ones would we have positive tracking arousal better

# maybe not every emotional experience causes a detectable physiologicachangedFiles(
# preparing ubjects might allow them to calibrate
```
abs
```{r}
# does absolute arousal correlate with other variables of interest
tmp.df4_full_stim_downs_jun2021_60bins$abs_arousal<- abs(tmp.df4_full_stim_downs_jun2021_60bins$arousal)

tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num< 500)%>%
  subset(!is.na(groun_valence))%>%
  group_by(ssid, stimIAPS)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(pup_basCor, arousal))+
  geom_point()+
  stat_smooth(aes(group = ssid),method = 'lm', se = F)
    ggpubr::stat_cor()

tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(!is.na(groun_valence))%>%
  group_by(ssid, stimIAPS)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(pup_basCor, abs_arousal))+
  geom_point()+
  geom_smooth(aes(group = ssid),method = 'lm', se = F)+
  ggpubr::stat_cor()+
  facet_grid()

tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(!is.na(groun_valence))%>%
  group_by(ssid, stimIAPS,ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  group_by(ssid,ground_valence_lab)%>%
  mutate(corar = cor(abs_arousal, pup_basCor, use = "complete"))%>%
  ggplot(aes(ground_valence_lab, corar))+
  # geom_point()
  stat_summary(geom = 'pointrange')


tmp.df4_full_stim_downs_jun2021_60bins %>%
  group_by(stimIAPS)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ArousalMean, ArousalMeanThisSample))+
  geom_point()+
  ggpubr::stat_cor()

tmp.df4_full_stim_downs_jun2021_60bins %>%
  group_by(stimIAPS)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ArousalMean, abs_arousal))+
  geom_point()+
  ggpubr::stat_cor()
# this again suggests that there is not too much of a problem in our response format as the absolute would be the equivalent of an scale that encodes for calence (direction)
```

a few checks on stim by ratings 
```{r eval=FALSE, include=FALSE}
<!-- tmp.df4_full_stim_downs_jun2021_60bins%>% -->
<!--   group_by(stimIAPS, ssid,valence_self)%>% -->
<!--   summarise_if(is.numeric, mean, na.rm = TRUE)%>% -->
<!--   ggplot(aes(stimIAPS, arousal, color = valence_self))+ -->
<!--   # geom_point()+ -->
<!--   stat_summary(funy = mean, geom = 'pointrange') -->


<!-- tmp.df4_full_stim_downs_jun2021_60bins%>% -->
<!--   group_by(stimIAPS, ssid,valence_self)%>% -->
<!--   summarise_if(is.numeric, mean, na.rm = TRUE)%>% -->
<!--   ggplot(aes(stimIAPS, abs(valence), color = valence_self))+ -->
<!--   # geom_point()+ -->
<!--   stat_summary(funy = mean, geom = 'pointrange') -->


<!-- tmp.df4_full_stim_downs_jun2021_60bins%>% -->
<!--   group_by(stimIAPS, ssid,ground_valence)%>% -->
<!--   summarise_if(is.numeric, mean, na.rm = TRUE)%>% -->
<!--   ggplot(aes(stimIAPS, abs(valence), color = ground_valence))+ -->
<!--   # geom_point()+ -->
<!--   stat_summary(funy = mean, geom = 'pointrange') -->
  
```

```{r}
# create the new arousal corrected within positive/negative - neutral
tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground_z <- ifelse(tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos == TRUE & 
                                                                      tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab == "More positive", tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground/ tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos_sd_arousal,
                                                                    ifelse(tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab == "More negative" & tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg == TRUE, tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground / 
                                                                             tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg_sd_arousal, 
                                                                           tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground/ sd(tmp.df4_full_stim_downs_jun2021_60bins$ArousalMean, na.rm = TRUE)))


# do the same with self report arousal but using ground valence?
tmp.df4_full_stim_downs_jun2021_60bins$arousal_self_rel_neutral_ground_z <- ifelse(tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos == TRUE & 
                                                                                     tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab == "More positive", tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground/ tmp.df4_full_stim_downs_jun2021_60bins$neutral_pos_sd_arousal,
                                                                    ifelse(tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab == "More negative" & tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg == TRUE, tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground / 
                                                                             tmp.df4_full_stim_downs_jun2021_60bins$neutral_neg_sd_arousal, 
                                                                           tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground/ sd(tmp.df4_full_stim_downs_jun2021_60bins$ArousalMean, na.rm = TRUE)))



table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground))
table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$arousal_rel_neutral_ground), tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab)


tmp.df4_full_stim_downs_jun2021_60bins%>%
  group_by(stimIAPS, ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ground_valence_lab, ArousalMean))+
  # geom_point()+
  # stat_summary(geom = 'pointrange')
 geom_boxplot()
tmp.df4_full_stim_downs_jun2021_60bins %>%
  group_by(stimIAPS, ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ground_valence_lab, arousal_rel_neutral_ground_z ))+
  # geom_point()+
  geom_boxplot()
  # stat_summary(geom = 'pointrange')


# original valence arousal
tmp.df4_full_stim_downs_jun2021_60bins %>%
  group_by(stimIAPS, ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ValenceMean, ArousalMean ))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()

tmp.df4_full_stim_downs_jun2021_60bins %>%
  group_by(stimIAPS, ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(ValenceMean, arousal_rel_neutral_ground_z ))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()



```



  valenc and arousla plots  
```{r}
  tmp.df4_full_stim_downs_jun2021_60bins %>%
  ungroup()%>%
  group_by(ground_valence_lab)%>%
  mutate(ArousalMean_z_by_val = scale(ArousalMean, center = TRUE, scale = TRUE)[,1])%>%
   mutate(Arousal_z_by_val = scale(arousal, center = TRUE, scale = TRUE)[,1])%>%
  group_by(stimIAPS,ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  # ggplot(aes(ground_valence_lab, ArousalMean_z_by_val ))+
  ggplot(aes(valence_c, ArousalMean ))+
  geom_point()+
  # geom_smooth(aes(group = ground_valence_lab), method = 'lm', se = F)
  stat_summary(geom = 'pointrange')+
  ggpubr::stat_cor()
  
  

      tmp.df4_full_stim_downs_jun2021_60bins %>%
  ungroup()%>%
  group_by(ground_valence_lab)%>%
  mutate(ArousalMean_z_by_val = scale(ArousalMean, center = TRUE, scale = TRUE)[,1])%>%
      
      group_by(ground_valence_lab)%>%
   mutate(Arousal_z_by_val = scale(arousal, center = TRUE, scale = TRUE)[,1])%>%
  group_by(stimIAPS,ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  # ggplot(aes(ground_valence_lab, ArousalMean_z_by_val ))+
  ggplot(aes(ArousalMean_z_by_val,pup_basCor ))+
  geom_point()+
      geom_smooth(method = 'lm', se = F)+
      ggpubr::stat_cor()
    
    tmp.df4_full_stim_downs_jun2021_60bins %>%
  ungroup()%>%
  group_by(ground_valence_lab)%>%
  mutate(ArousalMean_z_by_val = scale(ArousalMean, center = TRUE, scale = TRUE)[,1])%>%
      
      group_by(ground_valence_lab)%>%
   mutate(Arousal_z_by_val = scale(arousal, center = TRUE, scale = TRUE)[,1])%>%
  group_by(stimIAPS,ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  # ggplot(aes(ground_valence_lab, ArousalMean_z_by_val ))+
  ggplot(aes(Arousal_z_by_val,pup_basCor ))+
  geom_point()+
      geom_smooth(method = 'lm', se = F)+
      ggpubr::stat_cor()
  # geom_smooth(aes(color = ground_valence_lab), method = 'lm', se = F)
    
    
    
    # original variable
  
      tmp.df4_full_stim_downs_jun2021_60bins %>%
  ungroup()%>%
  group_by(ground_valence_lab)%>%
  mutate(ArousalMean_z_by_val = scale(ArousalMean, center = TRUE, scale = TRUE)[,1])%>%
      
      group_by(ground_valence_lab)%>%
   mutate(Arousal_z_by_val = scale(arousal, center = TRUE, scale = TRUE)[,1])%>%
  group_by(stimIAPS,ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  # ggplot(aes(ground_valence_lab, ArousalMean_z_by_val ))+
  ggplot(aes(pup_basCor,arousal))+
  geom_point()+
      geom_smooth(method = 'lm', se = F)+
      ggpubr::stat_cor()
      
      
      
  geom_smooth(aes(color = ground_valence_lab), method = 'lm', se = F)
        tmp.df4_full_stim_downs_jun2021_60bins %>%
  ungroup()%>%
  group_by(ground_valence_lab)%>%
  mutate(ArousalMean_z_by_val = scale(ArousalMean, center = TRUE, scale = TRUE)[,1])%>%
      
      group_by(ground_valence_lab)%>%
   mutate(Arousal_z_by_val = scale(arousal, center = TRUE, scale = TRUE)[,1])%>%
  group_by(stimIAPS,ground_valence_lab)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  # ggplot(aes(ground_valence_lab, ArousalMean_z_by_val ))+
  ggplot(aes(pup_basCor, ArousalMean))+
  geom_point()+
          geom_smooth(method = 'lm', se = F)+
          ggpubr::stat_cor()
  # geom_smooth(aes(group = ground_valence_lab), method = 'lm', se = F)
        

```


Pupil changes over time
<!-- 30 bins -->
```{r}

# create number s for time bins
tmp.df4_full_stim_downs_jun2021_with_behnew<- tmp.df4_full_stim_downs_jun2021_with_behnew%>%
  group_by(ssid, tNo)%>%
  mutate(timebin_no = 1:n())

range(tmp.df4_full_stim_downs_jun2021_with_behnew$timebin_no)

nbins<- unique(tmp.df4_full_stim_downs_jun2021_with_behnew$timebin_no)
nrow(nbins)
# nbins = 30 # number of bins

# create and empty dataframe for the timecourse analyses
timecourse_result_df_int <- data.frame(timebins= rep(NA, 30), 
                                       Estimate_ar= rep(NA, 30), 
                                       t_ar=rep(NA, 30), 
                                       p_ar=rep(NA, 30),
                                       Estimate_vl= rep(NA, 30), 
                                       t_vl=rep(NA, 30), 
                                       p_vl=rep(NA, 30),
                                       Estimate_br= rep(NA, 30), 
                                       t_br=rep(NA, 30), 
                                       p_br=rep(NA, 30),
                                       Estimate_ar_vl= rep(NA, 30), 
                                       t_ar_vl=rep(NA, 30), 
                                       p_ar_vl=rep(NA, 30),
                                       cov= as.character(rep(NA,30)))

# View(timecourse_result_df)
nbins<- nbins[1:28]

i = 0 # remember to always rezero it
# b = 10

# rm(i,b)


for (b in 1:length(nbins)) {
  # for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING lmer %i", nbins[b]))
        lmer_bin_pup  <- lmer(pup_basCor ~ arousal_c* valence+Mean_gray_z  +
                                (1 | ssid),
                                # (0 +arousal_c* valence | ssid),
                                # (1|stimIAPS),
                              REML = FALSE,
                      data = subset(tmp.df4_full_stim_downs_jun2021_with_behnew,
                                    # mediansplit_self_valence == "More positive" & 
                                    timebin_no == nbins[b]))

        #store results from the simulation
            lmer_bin_pup_summary<- summary(lmer_bin_pup)
            lmer_bin_pup_summary
            # lmer_bin_pup_summary[["coefficients"]][3,1]
            timecourse_result_df_int[i,1]<- tmp.df4_full_stim_downs_jun2021_with_behnew$timerezero3[b] #save the exact value of time bin
            
            timecourse_result_df_int[i,2]<- lmer_bin_pup_summary[["coefficients"]][5,1] # first number is term(row), second is column
            timecourse_result_df_int[i,3]<-lmer_bin_pup_summary[["coefficients"]][5,4] # t statistic
            timecourse_result_df_int[i,4]<-lmer_bin_pup_summary[["coefficients"]][5,5] # p value
            # simulated_clusters_JEFFE[i,6]<- nsim[s] #store simulation ount
            timecourse_result_df_int[i,5] <-ifelse(length(lmer_bin_pup_summary$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_pup_summary$optinfo$conv$lme4$message, 'pass')

     i = i+1
}


# timecourse_result_df_pos<- timecourse_result_df

timecourse_result_df_int %>%
  ggplot(aes(timebins, t))+
  geom_line(size = 2)+
  geom_line(aes(y = p), linetype = "dashed", size = 2)+
  geom_hline(yintercept = .05, color = 'red', size = 1.5)


```


60 bins

10 hz
each bin is an average of 100ms
<!-- https://link.springer.com/article/10.3758/s13428-018-1075-y -->

```{r}

# create number s for time bins

unique(tmp.df4_full_stim_downs_jun2021_60bins$ssid)

tmp.df4_full_stim_downs_jun2021_60bins<- tmp.df4_full_stim_downs_jun2021_60bins%>%
  group_by(ssid, tNo)%>%
  mutate(timebin_no = 1:n())

# let's test the interaction term
nbins<- unique(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)
range(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)

unique(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)

# nbins = 60 # number of bins

# create and empty dataframe for the timecourse analyses
timecourse_60bin_result_df <- data.frame(timebins= rep(NA, 60), 
                                       Estimate_ar= rep(NA, 60), 
                                       t_ar=rep(NA, 60), 
                                       p_ar=rep(NA, 60),
                                       Estimate_vl= rep(NA, 60), 
                                       t_vl=rep(NA, 60), 
                                       p_vl=rep(NA, 60),
                                       Estimate_br= rep(NA, 60), 
                                       t_br=rep(NA, 60), 
                                       p_br=rep(NA, 60),
                                       Estimate_ar_vl= rep(NA, 60), 
                                       t_ar_vl=rep(NA, 60), 
                                       p_ar_vl=rep(NA, 60),
                                       cov= as.character(rep(NA,60)))

# View(timecourse_result_df)
# nbins<- nbins[1:60]

i = 0 # remember to always rezero it
# b = 10

# rm(i,b)

# i =1
# unique(tmp.df4_full_stim_downs_jun2021_60bins$)



table(is.na(tmp.df4_full_stim_downs_jun2021_60bins$arousal_c))
for (b in 1:length(nbins)) {
  # for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING lmer %i", nbins[b]))
        lmer_bin_pup  <- lmer(pup_basCor ~ (arousal_c* valence)+Mean_gray_z  +
                                (1 | ssid),
                                # (0 +arousal_c* valence | ssid),
                                # (1|stimIAPS),
                              REML = FALSE,
                      data = subset(tmp.df4_full_stim_downs_jun2021_60bins,
                                    Group == "NT" &
                                    timebin_no == nbins[b]))

        #store results from the simulation
            lmer_bin_pup_summary<- summary(lmer_bin_pup)
            lmer_bin_pup_summary
            # lmer_bin_pup_summary[["coefficients"]][3,1]
            timecourse_60bin_result_df[i,1]<- tmp.df4_full_stim_downs_jun2021_60bins$timerezero3[b] 
            #save the exact value of time bin
            # store arousal (2,parameter)            # first number is term(row), second is column
            timecourse_60bin_result_df[i,2]<-
            lmer_bin_pup_summary[["coefficients"]][2,1] #estimate
            timecourse_60bin_result_df[i,3]<-
              lmer_bin_pup_summary[["coefficients"]][2,4] # t statistic
            timecourse_60bin_result_df[i,4]<-
            lmer_bin_pup_summary[["coefficients"]][2,5] # p value
            
            # valence
            
            timecourse_60bin_result_df[i,5]<-
            lmer_bin_pup_summary[["coefficients"]][3,1] #estimate
            timecourse_60bin_result_df[i,6]<-
              lmer_bin_pup_summary[["coefficients"]][3,4] # t statistic
            timecourse_60bin_result_df[i,7]<-
              lmer_bin_pup_summary[["coefficients"]][3,5] # p value
            
            # brighteness
            
            timecourse_60bin_result_df[i,8]<-
            lmer_bin_pup_summary[["coefficients"]][4,1] #estimate
            timecourse_60bin_result_df[i,9]<-
              lmer_bin_pup_summary[["coefficients"]][4,4] # t statistic
            timecourse_60bin_result_df[i,10]<-
              lmer_bin_pup_summary[["coefficients"]][4,5] # p value
            
            # interaction arousal x brighteness
            
            timecourse_60bin_result_df[i,11]<-
            lmer_bin_pup_summary[["coefficients"]][5,1] #estimate
            timecourse_60bin_result_df[i,12]<-
              lmer_bin_pup_summary[["coefficients"]][5,4] # t statistic
            timecourse_60bin_result_df[i,13]<-
              lmer_bin_pup_summary[["coefficients"]][5,5] # p value
            
            
            timecourse_60bin_result_df[i,14] <-
              ifelse(length(lmer_bin_pup_summary$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_pup_summary$optinfo$conv$lme4$message, 'pass')

     i = i+1
}


# timecourse_result_df_pos<- timecourse_result_df
View(timecourse_60bin_result_df)

  # geom_hline(yintercept = .05, color = 'red', size = 1.5)
  
# adjust p values and tag as TRUE whenevee there is at least 3 consecutive p values below .05
?p.adjust

timecourse_60bin_result_df$p_ar_adj<- p.adjust(timecourse_60bin_result_df$p_ar, method = "holm")
timecourse_60bin_result_df$p_ar_adj_TRUE<- if_else(timecourse_60bin_result_df$p_ar_adj<.05, TRUE, FALSE)


timecourse_60bin_result_df$p_vl_adj <- p.adjust(timecourse_60bin_result_df$p_vl, method = "holm")
timecourse_60bin_result_df$p_vl_adj_TRUE<- if_else(timecourse_60bin_result_df$p_vl_adj<.05, TRUE, FALSE)

timecourse_60bin_result_df$p_br_adj <- p.adjust(timecourse_60bin_result_df$p_br, method = "holm")
timecourse_60bin_result_df$p_br_adj_TRUE<- if_else(timecourse_60bin_result_df$p_br_adj<.05, TRUE, FALSE)

timecourse_60bin_result_df$p_ar_vl_adj <- p.adjust(timecourse_60bin_result_df$p_ar_vl, method = "holm")
timecourse_60bin_result_df$p_ar_vl_adj_TRUE<- if_else(timecourse_60bin_result_df$p_ar_vl_adj<.05, TRUE, NULL)

# find the first and last true in a sequence of TRUES
duplicated(timecourse_60bin_result_df$p_ar_adj_TRUE, na.rm = TRUE)



timecourse_60bin_result_df %>%
  ggplot(aes(timebins, Estimate_ar_vl))+
  # geom_line(size = 1)
  # geom_line(aes(y = t_vl), linetype = "dashed", size = 1)+
  # geom_line(aes(y = t_br), linetype = "dotted", size = 1)+
  # geom_line(aes(y = t_ar), linetype = "dotdash", size = 1, color = "red")
  # 

View(timecourse_60bin_result_df)


?p.adjust

# flad when 3 consecutive rows have a p <.05
require(zoo)

# rle performs lenght encoding
rletest<- rle(timecourse_60bin_result_df$p_ar<.05)
?rle

  (rletest$lengths[rletest$lengths > 3 & rletest$values== TRUE]) # length of each sequence

# To get the vector with only a sequence of "TRUE" you can try

rletest$values[rletest$values != TRUE] <- 0
timecourse_60bin_result_df$p_ar_3below.5<- rep(rletest$values,  rletest$lengths)

table(timecourse_60bin_result_df$p_ar_3below.5)
?p.adjust

timecourse_60bin_result_df%>%
  group_by(p_ar_3below.5)%>%
  mutate(p_ar_adj_clust= p.adjust(p_ar, method = "holm"))

timecourse_60bin_result_df %>%
  mutate(test=rollapply(p_ar, width=3, max, align="left", fill=NA, na.rm=TRUE))
  

View(timecourse_60bin_result_df)  

timecourse_60bin_result_df$timebins[timecourse_60bin_result_df$p_br_adj_TRUE == TRUE]

timecourse_60bin_result_df %>%
  group_by(p_br_adj_TRUE)%>%
  summarise_at(c("Estimate_br"), mean, na.rm = TRUE)
  mutate(mean_effsize = Estimate_br)
  
  
  #  arousal
  
  timecourse_60bin_result_df$timebins[timecourse_60bin_result_df$p_ar_adj_TRUE == TRUE]

 timecourse_60bin_result_df %>%
  group_by(p_ar_adj_TRUE)%>%
  summarise_at(c("Estimate_ar"), mean, na.rm = TRUE)
 
 
 # ar and val;
   timecourse_60bin_result_df$timebins[timecourse_60bin_result_df$p_ar_vl_adj_TRUE == TRUE]

 timecourse_60bin_result_df %>%
  group_by(p_ar_vl_adj_TRUE)%>%
  summarise_at(c("Estimate_ar_vl"), median, na.rm = TRUE)

 
 # valence
  # ar and val;
   timecourse_60bin_result_df$timebins[timecourse_60bin_result_df$p_vl_adj_TRUE == TRUE]

 timecourse_60bin_result_df %>%
  group_by(p_vl_adj_TRUE)%>%
  summarise_at(c("Estimate_vl"), median, na.rm = TRUE)

```

# # figure preferences
good blog in customization 
https://www.datanovia.com/en/blog/ggplot-legend-title-position-and-labels/#rename-legend-labels-and-change-the-order-of-items
```{r}
p<- list()

sf = 1 # scaling factor to make it easier to change sizes of everything, in which case change here

p$graphstyle <-  theme(#base plot theme
  
  # axis lines
  axis.line.y = element_line(color="black"),
  axis.line.x = element_line(color="black"),
  
  axis.title.y=element_text(size = 16*(sf+.5), margin=margin(0,5,0,0)),
  axis.title.x=element_text(size = 16*(sf+.5), margin=margin(0,5,0,0)),
  
  # text
  strip.text.x = element_text(size = 12*(sf+.5),  colour = "black"),
  strip.text.y = element_text(size = 12*(sf+.5),  colour = "black"),
  
  text=element_text(size = 14, family = "sans"),
  axis.text.x = element_text(size = 14*(sf+.5), family = "sans", colour = "black",),
  axis.text.y = element_text(size = 14*(sf+.5), family = "sans", colour = "black"),
  
  
  # panel
  panel.grid.major = element_blank(),
  panel.background = element_blank(),
  # panel.background = element_rect(fill="transparent"),
  # panel.border = element_rect(fill="transparent"),
  # strip shades (reco rectagles)
   strip.background = element_blank(),
  
  # legend
  legend.position = "top",
  legend.key = element_rect(colour = "transparent", fill="transparent"),
  #legend.direction = "horizontal",

  legend.text = element_text(size = 10*(sf+.3)),
  # legend.title = element_text(size = 10*(sf+.3)),
  # legend line tends to be really small in print so adjust here
  legend.key.height = unit(.5, "cm"),
  legend.key.width = unit(2, "cm"),
  
  #legend.text = element_text(size = 10*sf),
  legend.title=element_blank(),
  #legend.text = element_blank(),
  #axis.ticks = element_blank(),
)


```


timecourse stats plots
```{r}
require(RColorBrewer) # make color friendly plots
require(tidyverse)

brewer.pal(4, "Dark2") # gives the exact names of pallets
  # "#1B9E77" "#D95F02" "#7570B3" "#E7298A"
  # timecourse_60bin_result_df$
  # Estimate_ar, Estimate_ar_vl,Estimate_br. Estimate_v
  
plots_timecourse <- list()

#  let's use the order arousal, valence, arousal x valence brightness
View(timecourse_60bin_result_df)

plots_timecourse$eff_size_pup_amp <-   timecourse_60bin_result_df[1:56,] %>% 
  select("timebins","Estimate_ar", "Estimate_vl", "Estimate_br", "Estimate_ar_vl") %>% 
  pivot_longer(-timebins, names_to = "variable", values_to = "Estimate")%>%
    subset(!is.na(Estimate))%>%
  #change the order of the coloring variable here and the name of legends
  mutate(variable = factor(variable, c("Estimate_ar", "Estimate_vl","Estimate_ar_vl",  "Estimate_br"), labels = c("arousal", "valence", "arousal x valence", "brightness")))%>%
  ggplot(aes(timebins, Estimate, group = variable, color= variable))+
  geom_line(aes(linetype = variable), size = 1)+
  
  scale_color_brewer(palette = "Dark2")+
    # scale_color_manual(values=c("#1B9E77", "#D95F02", "#7570B3", "#E7298A"))+
  # use hom correction for significance
  
    # brighteness
    # timecourse_60bin_result_df$timebins[timecourse_60bin_result_df$p_br_adj_TRUE == TRUE]
  
    annotate(geom = 'rect', # use annotate instead of geom_rect, as it is more flexible
             xmin = .16, # got these values from the data-frame. need to fidn a way to automate this
                xmax = 6,
                ymin = -2.03+(sf*.3), # if I ever need to change this, use the scaling factor sf
                ymax = -2+.1+.01+(sf*.3),
                fill =  "#E7298A" , alpha = .5)+ 
    
      annotate("text", 
                x = (1+5.4)/2,
                y = ((-2) +(-2+.1))/2+(sf*.3),
                label = "brightness") +
    
    # arousal
  
    # timecourse_60bin_result_df$p_ar_adj
    # timecourse_60bin_result_df$timebins[timecourse_60bin_result_df$p_ar_adj_TRUE == TRUE]
     annotate(geom = 'rect', xmin = 1,
                xmax = 5.89,
                ymin = -2.03+.1+.1+.1+.1+(sf*.3),
                ymax = -2+.1+.1+.1+.1+.1+.01+(sf*.3),
                fill = "#1B9E77", alpha = .5)+
        annotate("text", 
                  x = (1+5.4)/2,
                y = ((-2+.1+.1+.1+.1) +(-2+.1+.1+.1+.1+.1))/2+(sf*.3),
                 label = "arousal") +

    # arousal-valence
   # timecourse_60bin_result_df$p_ar_vl_adj
    # timecourse_60bin_result_df$timebins[timecourse_60bin_result_df$p_ar_vl_adj_TRUE == TRUE]
       annotate(geom = 'rect', 
                xmin = 1,
                xmax = 5.4,
                ymin = -2.03+.1+.1+(sf*.3),
                ymax = -2+.1+.1+.1+.01+(sf*.3),
                
                fill ="#7570B3", alpha = .5, label = "text")+
    annotate("text", 
                x = (1+5.4)/2,
                y = ((-2+.1+.1) +(-2+.1+.1+.1))/2+(sf*.3),
                label = "arousal x valence") +
        xlab("Time (s)")+
    ylab("Effect size")+
    xlab("Time (s)")+
    ylab("Effect size")

plots_timecourse$eff_size_pup_amp 
# need to rename the label legends


# Edit legend title and labels
plots_timecourse$eff_size_pup_amp <- plots_timecourse$eff_size_pup_amp + 
  p$graphstyle +
    guides(colour = guide_legend(override.aes = list(size=2)))+ #the line size of the legend tends to be smaller in print
  scale_x_continuous(limits = c(0,6), breaks = c(0,2,4,6))+
  scale_y_continuous(limits = c(-2,.7), breaks = c(-1, -0.5, 0,0.5))
  


plots_timecourse$eff_size_pup_amp
plots_timecourse$eff_size_pup_velocity

```


split neutral positive and negative using IAPS validation data and fit the same

```{r}

colnames(tmp.df4_full_stim_downs_jun2021_60bins)

tmp.df4_full_stim_downs_jun2021_60bins$ground_arousal_lab
tmp.df4_full_stim_downs_jun2021_60bins$ground_valence_lab

nbins<- unique(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)
# create and empty data-frame for the time-course analyses

View(timecourse_60bin_result_df_pos)
timecourse_60bin_result_df_pos <- data.frame(timebins= rep(NA, 60), 
                                       Estimate_ar= rep(NA, 60), 
                                       t_ar=rep(NA, 60), 
                                       p_ar=rep(NA, 60),
                                       # Estimate_vl= rep(NA, 60), 
                                       # t_vl=rep(NA, 60), 
                                       # p_vl=rep(NA, 60),
                                       Estimate_br= rep(NA, 60), 
                                       t_br=rep(NA, 60), 
                                       p_br=rep(NA, 60),
                                       # Estimate_ar_vl= rep(NA, 60), 
                                       # t_ar_vl=rep(NA, 60), 
                                       # p_ar_vl=rep(NA, 60),
                                       cov= as.character(rep(NA,60)))

# View(timecourse_result_df)
# nbins<- nbins[1:60]

i = 0 # remember to always rezero it
# b = 10

# rm(i,b)

# i =1
# unique(tmp.df4_full_stim_downs_jun2021_60bins$)

for (b in 1:length(nbins)) {
  # for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING lmer %i", nbins[b]))
        lmer_bin_pup  <- lmer(pup_basCor ~ arousal_c + Mean_gray_z  +
                                (1 | ssid),
                              REML = FALSE,
                      data = subset(tmp.df4_full_stim_downs_jun2021_60bins,
                                    ssid_num < 500 & ground_valence_lab == "More positive" &
                                    timebin_no == nbins[b]))

        #store results from the simulation
            lmer_bin_pup_summary<- summary(lmer_bin_pup)
            lmer_bin_pup_summary
            # lmer_bin_pup_summary[["coefficients"]][3,1]
            timecourse_60bin_result_df_pos[i,1]<- tmp.df4_full_stim_downs_jun2021_60bins$timerezero3[b] 
            #save the exact value of time bin
            # store arousal (2,parameter)            # first number is term(row), second is column
            timecourse_60bin_result_df_pos[i,2]<-
            lmer_bin_pup_summary[["coefficients"]][2,1] #estimate
            timecourse_60bin_result_df_pos[i,3]<-
              lmer_bin_pup_summary[["coefficients"]][2,4] # t statistic
            timecourse_60bin_result_df_pos[i,4]<-
            lmer_bin_pup_summary[["coefficients"]][2,5] # p value
            
            # brightness
            
            timecourse_60bin_result_df_pos[i,5]<-
            lmer_bin_pup_summary[["coefficients"]][3,1] #estimate
            timecourse_60bin_result_df_pos[i,6]<-
              lmer_bin_pup_summary[["coefficients"]][3,4] # t statistic
            timecourse_60bin_result_df_pos[i,7]<-
              lmer_bin_pup_summary[["coefficients"]][3,5] # p value

            
            timecourse_60bin_result_df_pos[i,8] <-
              ifelse(length(lmer_bin_pup_summary$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_pup_summary$optinfo$conv$lme4$message, 'pass')

     i = i+1
}


# timecourse_result_df_pos<- timecourse_result_df
View(timecourse_60bin_result_df_pos)

  
  # geom_hline(yintercept = .05, color = 'red', size = 1.5)
  

# adjust p values and tag as TRUE whenevee there is at least 3 consecutive p values below .05

timecourse_60bin_result_df_pos$p_ar_adj<- p.adjust(timecourse_60bin_result_df_pos$p_ar, method = "holm")
timecourse_60bin_result_df_pos$p_ar_adj_TRUE<- if_else(timecourse_60bin_result_df_pos$p_ar_adj<.05, TRUE, FALSE)


timecourse_60bin_result_df_pos$p_br_adj <- p.adjust(timecourse_60bin_result_df_pos$p_br, method = "holm")
timecourse_60bin_result_df_pos$p_br_adj_TRUE<- if_else(timecourse_60bin_result_df_pos$p_br_adj<.05, TRUE, FALSE)


timecourse_60bin_result_df_pos[1:56,] %>%
  ggplot(aes(timebins, Estimate_ar))+
  geom_line(size = 1)+
  geom_line(aes(y = Estimate_br), linetype = "dashed", size = 1)

  

# subset(tmp.df4_full_stim_downs_jun2021_60bins,
#                                     ssid_num < 500 & ground_valence_lab == "More positive"
#                                    )%>%
#   # group_by(stimIAPS)%>%
#   # summarise_if(is.numeric, mean, na.rm = TRUE)%>%
#   # ggplot(aes(valence, Mean))+
#   # geom_point()+
#   # geom_smooth(method = 'lm', se = F)+
#   # ggpubr::stat_cor()

```
neutral


```{r}



nbins<- unique(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)
# create and empty data-frame for the time-course analyses

View(timecourse_60bin_result_df_pos)

timecourse_60bin_result_df_neutral <- data.frame(timebins= rep(NA, 60), 
                                       Estimate_ar= rep(NA, 60), 
                                       t_ar=rep(NA, 60), 
                                       p_ar=rep(NA, 60),
                                       # Estimate_vl= rep(NA, 60), 
                                       # t_vl=rep(NA, 60), 
                                       # p_vl=rep(NA, 60),
                                       Estimate_br= rep(NA, 60), 
                                       t_br=rep(NA, 60), 
                                       p_br=rep(NA, 60),
                                       # Estimate_ar_vl= rep(NA, 60), 
                                       # t_ar_vl=rep(NA, 60), 
                                       # p_ar_vl=rep(NA, 60),
                                       cov= as.character(rep(NA,60)))

# View(timecourse_result_df)
# nbins<- nbins[1:60]

i = 0 # remember to always rezero it
# b = 10

# rm(i,b)

# i =1
# unique(tmp.df4_full_stim_downs_jun2021_60bins$)
for (b in 1:length(nbins)) {
  # for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING lmer %i", nbins[b]))
        lmer_bin_pup  <- lmer(pup_basCor ~ arousal_c + Mean_gray_z  +
                                (1 | ssid),
                              REML = FALSE,
                      data = subset(tmp.df4_full_stim_downs_jun2021_60bins,
                                    ssid_num < 500 & ground_valence_lab == "Mild" &
                                    timebin_no == nbins[b]))

        #store results from the simulation
            lmer_bin_pup_summary<- summary(lmer_bin_pup)
            lmer_bin_pup_summary
            # lmer_bin_pup_summary[["coefficients"]][3,1]
            timecourse_60bin_result_df_neutral[i,1]<- tmp.df4_full_stim_downs_jun2021_60bins$timerezero3[b] 
            #save the exact value of time bin
            # store arousal (2,parameter)            # first number is term(row), second is column
            timecourse_60bin_result_df_neutral[i,2]<-
            lmer_bin_pup_summary[["coefficients"]][2,1] #estimate
            timecourse_60bin_result_df_neutral[i,3]<-
              lmer_bin_pup_summary[["coefficients"]][2,4] # t statistic
            timecourse_60bin_result_df_neutral[i,4]<-
            lmer_bin_pup_summary[["coefficients"]][2,5] # p value
            
            # brightness
            
            timecourse_60bin_result_df_neutral[i,5]<-
            lmer_bin_pup_summary[["coefficients"]][3,1] #estimate
            timecourse_60bin_result_df_neutral[i,6]<-
              lmer_bin_pup_summary[["coefficients"]][3,4] # t statistic
            timecourse_60bin_result_df_neutral[i,7]<-
              lmer_bin_pup_summary[["coefficients"]][3,5] # p value

            
            timecourse_60bin_result_df_neutral[i,8] <-
              ifelse(length(lmer_bin_pup_summary$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_pup_summary$optinfo$conv$lme4$message, 'pass')

     i = i+1
}


# timecourse_result_df_pos<- timecourse_result_df
View(timecourse_60bin_result_df_neutral)


timecourse_60bin_result_df_neutral$p_ar_adj<- p.adjust(timecourse_60bin_result_df_neutral$p_ar, method = "holm")
timecourse_60bin_result_df_neutral$p_ar_adj_TRUE<- if_else(timecourse_60bin_result_df_neutral$p_ar_adj<.05, TRUE, FALSE)


timecourse_60bin_result_df_neutral$p_br_adj <- p.adjust(timecourse_60bin_result_df_neutral$p_br, method = "holm")
timecourse_60bin_result_df_neutral$p_br_adj_TRUE<- if_else(timecourse_60bin_result_df_neutral$p_br_adj<.05, TRUE, FALSE)



View(timecourse_60bin_result_df_neutral)
timecourse_60bin_result_df_neutral[1:56,] %>%
  ggplot(aes(timebins, Estimate_ar))+
  geom_line(size = 1)+
  geom_line(aes(y = Estimate_br), linetype = "dashed", size = 1)


```


negative


```{r}



nbins<- unique(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)
# create and empty data-frame for the time-course analyses

View(timecourse_60bin_result_df_pos)

timecourse_60bin_result_df_neg <- data.frame(timebins= rep(NA, 60), 
                                       Estimate_ar= rep(NA, 60), 
                                       t_ar=rep(NA, 60), 
                                       p_ar=rep(NA, 60),
                                       # Estimate_vl= rep(NA, 60), 
                                       # t_vl=rep(NA, 60), 
                                       # p_vl=rep(NA, 60),
                                       Estimate_br= rep(NA, 60), 
                                       t_br=rep(NA, 60), 
                                       p_br=rep(NA, 60),
                                       # Estimate_ar_vl= rep(NA, 60), 
                                       # t_ar_vl=rep(NA, 60), 
                                       # p_ar_vl=rep(NA, 60),
                                       cov= as.character(rep(NA,60)))

# View(timecourse_result_df)
# nbins<- nbins[1:60]

i = 0 # remember to always rezero it
# b = 10

# rm(i,b)

# i =1
# unique(tmp.df4_full_stim_downs_jun2021_60bins$)

for (b in 1:length(nbins)) {
  # for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING lmer %i", nbins[b]))
        lmer_bin_pup  <- lmer(pup_basCor ~ arousal_c + Mean_gray_z  +
                                (1 | ssid),
                              REML = FALSE,
                      data = subset(tmp.df4_full_stim_downs_jun2021_60bins,
                                    ssid_num < 500 & ground_valence_lab == "More negative" &
                                    timebin_no == nbins[b]))

        #store results from the simulation
            lmer_bin_pup_summary<- summary(lmer_bin_pup)
            lmer_bin_pup_summary
            # lmer_bin_pup_summary[["coefficients"]][3,1]
            timecourse_60bin_result_df_neg[i,1]<- tmp.df4_full_stim_downs_jun2021_60bins$timerezero3[b] 
            #save the exact value of time bin
            # store arousal (2,parameter)            # first number is term(row), second is column
            timecourse_60bin_result_df_neg[i,2]<-
            lmer_bin_pup_summary[["coefficients"]][2,1] #estimate
            timecourse_60bin_result_df_neg[i,3]<-
              lmer_bin_pup_summary[["coefficients"]][2,4] # t statistic
            timecourse_60bin_result_df_neg[i,4]<-
            lmer_bin_pup_summary[["coefficients"]][2,5] # p value
            
            # brightness
            
            timecourse_60bin_result_df_neg[i,5]<-
            lmer_bin_pup_summary[["coefficients"]][3,1] #estimate
            timecourse_60bin_result_df_neg[i,6]<-
              lmer_bin_pup_summary[["coefficients"]][3,4] # t statistic
            timecourse_60bin_result_df_neg[i,7]<-
              lmer_bin_pup_summary[["coefficients"]][3,5] # p value

            
            timecourse_60bin_result_df_neg[i,8] <-
              ifelse(length(lmer_bin_pup_summary$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_pup_summary$optinfo$conv$lme4$message, 'pass')

     i = i+1
}


# timecourse_result_df_pos<- timecourse_result_df
View(timecourse_60bin_result_df_neg)

# adjust p values
timecourse_60bin_result_df_neg$p_ar_adj<- p.adjust(timecourse_60bin_result_df_neg$p_ar, method = "holm")
timecourse_60bin_result_df_neg$p_ar_adj_TRUE<- if_else(timecourse_60bin_result_df_neg$p_ar_adj<.05, TRUE, FALSE)


timecourse_60bin_result_df_neg$p_br_adj <- p.adjust(timecourse_60bin_result_df_neg$p_br, method = "holm")
timecourse_60bin_result_df_neg$p_br_adj_TRUE<- if_else(timecourse_60bin_result_df_neg$p_br_adj<.05, TRUE, FALSE)



View(timecourse_60bin_result_df_neg)

timecourse_60bin_result_df_neg[1:56,] %>%
  ggplot(aes(timebins, Estimate_ar))+
  geom_line(size = 1)+
  geom_line(aes(y = Estimate_br), linetype = "dashed", size = 1)


```
Pupil velocity test
# velocity analyses

30hz
```{r}
# install.packages("pspline")
library(pspline)

predict(sm.spline(tmp.df4_full_stim_downs_jun2021_with_beh$timerezero3, 
                  tmp.df4_full_stim_downs_jun2021_with_beh$pup_basCor), 
        tmp.df4_full_stim_downs_jun2021_with_beh$timerezero3, 1)

D(tmp.df4_full_stim_downs_jun2021_with_beh$pup_basCor, 'x')

tmp.df4_full_stim_downs_jun2021_with_behnew

tmp.df4_full_stim_downs_jun2021_with_behnew <- tmp.df4_full_stim_downs_jun2021_with_behnew %>%
  # subset(!is.na(mediansplit_sample_arousal2))%>%
  # subset(valencearousal_outliers == TRUE) %>%
  # subset(!is.na(mediansplit_sample_arousal2))%>%
  group_by(ssid, stimIAPS) %>%
  mutate(pup_velocity = (abs(lag(pup_basCor)-pup_basCor)/abs(lag(timerezero3)-timerezero3)))
  # mutate(pup_velocity_peak = max(pup_velocity, na.rm = TRUE))


tmp.df4_full_stim_downs_jun2021_with_behnew$pup_velocity

# global

nrow(nbins)
nbins = 30 # number of bins
unique(tmp.df4_full_stim_downs_jun2021_with_behnew$ssid)
tmp.df4_full_stim_downs_jun2021_with_behnew <- tmp.df4_full_stim_downs_jun2021_with_behnew%>%
  group_by(ssid, tNo)%>%
  arrange(ssid,tNo, timerezero3)%>%
  mutate(pup_vel_smooth = zoo::rollmean(pup_velocity, k = 3, fill = NA))
  
zoo::rollmean(pup_velocity, k = 3, fill = NA)

tmp.df4_full_stim_downs_jun2021_with_behnew$pup_vel_smooth

# create and empty dataframe for the timecourse analyses
timecourse_result_df_int_vel <- data.frame(timebins= rep(NA, 30), Estimate= rep(NA, 30), 
                                   t=rep(NA, 30), p=rep(NA, 30), cov= as.character(rep(NA,30)))

# View(timecourse_result_df)
nbins<- nbins[1:28]

i = 0 # remember to always rezero it
# b = 10

rm(b)

nbins<- unique(tmp.df4_full_stim_downs_jun2021_with_behnew$timebin_no)

for (b in 3:length(nbins)) {
  # for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING lmer %i", nbins[b]))
        lmer_bin_pup  <- lmer(pup_vel_smooth ~ arousal_c* valence+Mean_gray_z  +
                                (1 | ssid)+
                                (0 +arousal_c* valence | ssid),
                                # (1|stimIAPS),
                              REML = FALSE,
                      data = subset(tmp.df4_full_stim_downs_jun2021_with_behnew,
                                    # mediansplit_self_valence == "More positive" & 
                                    timebin_no == nbins[b]))

        #store results from the simulation
            lmer_bin_pup_summary<- summary(lmer_bin_pup)
            lmer_bin_pup_summary
            # lmer_bin_pup_summary[["coefficients"]][3,1]
            timecourse_result_df_int_vel[i,1]<- tmp.df4_full_stim_downs_jun2021_with_behnew$timerezero3[b] #save the exact value of time bin
            timecourse_result_df_int_vel[i,2]<- lmer_bin_pup_summary[["coefficients"]][2,1] # first number is term(row), second is column
            timecourse_result_df_int_vel[i,3]<-lmer_bin_pup_summary[["coefficients"]][2,4] # t statistic
            timecourse_result_df_int_vel[i,4]<-lmer_bin_pup_summary[["coefficients"]][2,5] # p value
            # simulated_clusters_JEFFE[i,6]<- nsim[s] #store simulation ount
            timecourse_result_df_int_vel[i,5] <-ifelse(length(lmer_bin_pup_summary$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_pup_summary$optinfo$conv$lme4$message, 'pass')

     i = i+1
}


# timecourse_result_df_pos<- timecourse_result_df

timecourse_result_df_int_vel %>%
  ggplot(aes(timebins, t))+
  geom_line(size = 2)+
  geom_line(aes(y = p), linetype = "dashed", size = 2)+
  geom_hline(yintercept = .05, color = 'red', size = 1.5)+
  geom_vline(xintercept = 1, color = 'red')
  # ylim(-4,4)


??ma
?stats::filter
tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid == 310 & tNo == 10)%>%
  ggplot(aes(timerezero3,pup_vel_smooth))+
  geom_line()+
  geom_point()
  # geom_line(aes(y = pup_velocity),Ç color = 'red')
  # geom_smooth(se = F)

tmp.df4_full_stim_downs_jun2021_60bins%>%
    subset(ssid == 320 & tNo == 20)%>%
  ggplot(aes(timerezero3,pup_basCor))+
  geom_point()+
  geom_line()+
  geom_line(aes(y = pup_vel_smooth), color = 'red')+
  geom_point(aes(y = pup_vel_smooth), color = 'red')
  # geom_line(aes(y = pup_velocity), color = 'red')+
  # geom_smooth(se = F)




```


velocity 100ms
```{r}
unique(tmp.df4_full_stim_downs_jun2021_60bins$ssid)

tmp.df4_full_stim_downs_jun2021_60bins$ssid_num<- as.numeric(as.character(tmp.df4_full_stim_downs_jun2021_60bins$ssid))

tmp.df4_full_stim_downs_jun2021_60bins <- tmp.df4_full_stim_downs_jun2021_60bins %>%
  # subset(!is.na(mediansplit_sample_arousal2))%>%
  # subset(valencearousal_outliers == TRUE) %>%
  # subset(!is.na(mediansplit_sample_arousal2))%>%
  group_by(ssid, tNo) %>%
  mutate(pup_velocity = (abs(lag(pup_basCor)-pup_basCor)/abs(lag(timerezero3)-timerezero3)))%>%
  mutate(pup_velocity_dir = ((lag(pup_basCor)-pup_basCor) / abs(lag(timerezero3)-timerezero3)))
  # mutate(pup_velocity_peak = max(pup_velocity, na.rm = TRUE))


tmp.df4_full_stim_downs_jun2021_60bins%>%
  subset(ssid == 325 & tNo ==38)%>%
  ggplot(aes(timerezero3, pup_velocity))+
  geom_line()

tmp.df4_full_stim_downs_jun2021_60bins%>%
  subset(ssid == 325 & tNo ==38)%>%
  ggplot(aes(timerezero3, pup_basCor))+
  geom_line()

# compared to pupil velocity is much more jerky

# smooth belocity
# number of bins
unique(tmp.df4_full_stim_downs_jun2021_with_behnew$ssid)
tmp.df4_full_stim_downs_jun2021_with_behnew


tmp.df4_full_stim_downs_jun2021_60bins<- tmp.df4_full_stim_downs_jun2021_60bins%>%
  # subset(ssid == 331 & tNo ==40)%>%
  group_by(ssid, tNo)%>%
  arrange(ssid,tNo, timerezero3)%>%
  mutate(pup_vel_smooth = zoo::rollmean(pup_velocity, k = 3, fill = NA))
   ggplot(aes(timerezero3, pup_velocity))+
  geom_line()+
  geom_line(aes(y = pup_vel_smooth), color = 'red')


tmp.df4_full_stim_downs_jun2021_60bins$four<- paste0(tmp.df4_full_stim_downs_jun2021_60bins$mediansplit_sample_arousal2,
                                                     paste0(tmp.df4_full_stim_downs_jun2021_60bins$mediansplit_sample_valence2))
                                                     
# paste0(tmp.df4_full_stim_downs_jun2021_60bins$mediansplit_sample_arousal2)


# unique(tmp.df4_full_stim_downs_jun2021_60bins)


  tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num < 500)%>%
  subset(!is.na(mediansplit_sample_valence2))%>%
  group_by(ssid, tNo)%>%
  arrange(ssid,tNo, timerezero3)%>%
   ggplot(aes(timerezero3, pup_basCor, color = four))+
  stat_smooth(se = F)
  # geom_line(aes(y = pup_vel_smooth), color = 'red')
  
tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num < 500)%>%
  subset(!is.na(mediansplit_sample_valence2))%>%
  group_by(ssid, tNo)%>%
  arrange(ssid,tNo, timerezero3)%>%
   ggplot(aes(timerezero3, pup_velocity, color = four))+
  stat_smooth(se = T)
  # stat_smooth(aes(y = pup_velocity_dir),se = F, linetype = 'dashed')
  # geom_line(aes(y = pup_vel_smooth), color = 'red')


tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num < 500)%>%
  subset(!is.na(mediansplit_sample_valence2))%>%
  group_by(ssid, tNo)%>%
  arrange(ssid,tNo, timerezero3)%>%
   ggplot(aes(timerezero3, pup_velocity_dir, color = four))+
  # stat_summary(fun = mean, geom = 'line')
  stat_smooth(se = T)
  # stat_smooth(aes(y = pup_velocity_dir),se = F, linetype = 'dashed')
  # geom_line(aes(y = pup_vel_smooth), color = 'red')


```

```{r}  
  tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num < 500)%>%
  subset(!is.na(mediansplit_sample_valence2))%>%
  group_by(ssid, tNo)%>%
  arrange(ssid,tNo, timerezero3)%>%
   ggplot(aes(timerezero3, pup_basCor, color = four))+
  stat_smooth(se = F)
  geom_line(aes(y = pup_vel_smooth), color = 'red')
  
  
  tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num < 500)%>%
  subset(!is.na(mediansplit_sample_valence2))%>%
  group_by(ssid, tNo)%>%
  arrange(ssid,tNo, timerezero3)%>%
   ggplot(aes(timerezero3, pup_vel_smooth, color = four))+
  stat_smooth(se = F)
  geom_line(aes(y = pup_vel_smooth), color = 'red')

  
  tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num < 500)%>%
  subset(!is.na(mediansplit_sample_valence2))%>%
  group_by(ssid, tNo)%>%
  arrange(ssid,tNo, timerezero3)%>%
   ggplot(aes(timerezero3, pup_basCor, color = four))+
  stat_smooth(se = F)
  geom_line(aes(y = pup_vel_smooth), color = 'red')



  

```




is velocity correlated with puypil amplitude
```{r}
require(tidyverse)

tmp.df4_full_stim_downs_jun2021_60bins %>%
  group_by(stimIAPS)%>%
  mutate(cor_vel_pup = cor(pup_vel_smooth,pup_basCor, use = 'complete'))%>%
  mutate(vel_max = max(pup_vel_smooth,na.rm = TRUE))%>%
  summarise_if(is.numeric, mean,na.rm = TRUE)%>%
  ggplot(aes(vel_max,pup_basCor))+
  geom_point()+
  geom_smooth(method = 'lm')+
  ggpubr::stat_cor()

```
velocity timecourse
```{r}
# let's test the interaction term
nbins<- unique(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)
range(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)

unique(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)

# nbins = 60 # number of bins

# create and empty dataframe for the timecourse analyses
timecourse_60bin_result_df_vel <- data.frame(timebins= rep(NA, 60), 
                                       Estimate_ar= rep(NA, 60), 
                                       t_ar=rep(NA, 60), 
                                       p_ar=rep(NA, 60),
                                       Estimate_vl= rep(NA, 60), 
                                       t_vl=rep(NA, 60), 
                                       p_vl=rep(NA, 60),
                                       Estimate_br= rep(NA, 60), 
                                       t_br=rep(NA, 60), 
                                       p_br=rep(NA, 60),
                                       Estimate_ar_vl= rep(NA, 60), 
                                       t_ar_vl=rep(NA, 60), 
                                       p_ar_vl=rep(NA, 60),
                                       cov= as.character(rep(NA,60)))

# View(timecourse_result_df)
# nbins<- nbins[1:60]

i = 0 # remember to always rezero it
# b = 10

# rm(i,b)

tmp.df4_full_stim_downs_jun2021_60bins$pup_vel_smooth

nbins<- nbins[3:59]

for (b in 3:length(nbins)) {
  # for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING lmer %i", nbins[b]))
        lmer_bin_pup  <- lmer(pup_velocity ~ (arousal_c* valence)+Mean_gray_z  +
                                (1 | ssid),
                                # (0 +arousal_c* valence | ssid),
                                # (1|stimIAPS),
                              REML = FALSE,
                      data = subset(tmp.df4_full_stim_downs_jun2021_60bins,
                                    !is.na(pup_velocity)&
                                     Group == "NT" &
                                    timebin_no == nbins[b]))

        # store results from the simulation
            lmer_bin_pup_summary<- summary(lmer_bin_pup)
            lmer_bin_pup_summary
            # lmer_bin_pup_summary[["coefficients"]][3,1]
            timecourse_60bin_result_df_vel[i,1]<- tmp.df4_full_stim_downs_jun2021_60bins$timerezero3[b] 
            #save the exact value of time bin
            # store arousal (2,parameter)            # first number is term(row), second is column
            timecourse_60bin_result_df_vel[i,2]<-
            lmer_bin_pup_summary[["coefficients"]][2,1] #estimate
            timecourse_60bin_result_df_vel[i,3]<-
              lmer_bin_pup_summary[["coefficients"]][2,4] # t statistic
            timecourse_60bin_result_df_vel[i,4]<-
            lmer_bin_pup_summary[["coefficients"]][2,5] # p value
            
            # valence
            
            timecourse_60bin_result_df_vel[i,5]<-
            lmer_bin_pup_summary[["coefficients"]][3,1] #estimate
            timecourse_60bin_result_df_vel[i,6]<-
              lmer_bin_pup_summary[["coefficients"]][3,4] # t statistic
            timecourse_60bin_result_df_vel[i,7]<-
              lmer_bin_pup_summary[["coefficients"]][3,5] # p value
            
            # brighteness
            
            timecourse_60bin_result_df_vel[i,8]<-
            lmer_bin_pup_summary[["coefficients"]][4,1] #estimate
            timecourse_60bin_result_df_vel[i,9]<-
              lmer_bin_pup_summary[["coefficients"]][4,4] # t statistic
            timecourse_60bin_result_df_vel[i,10]<-
              lmer_bin_pup_summary[["coefficients"]][4,5] # p value
            
            # interaction arousal x brighteness
            
            timecourse_60bin_result_df_vel[i,11]<-
            lmer_bin_pup_summary[["coefficients"]][5,1] #estimate
            timecourse_60bin_result_df_vel[i,12]<-
              lmer_bin_pup_summary[["coefficients"]][5,4] # t statistic
            timecourse_60bin_result_df_vel[i,13]<-
              lmer_bin_pup_summary[["coefficients"]][5,5] # p value
            
            
            timecourse_60bin_result_df_vel[i,14] <-
              ifelse(length(lmer_bin_pup_summary$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_pup_summary$optinfo$conv$lme4$message, 'pass')

     i = i+1
}
# timecourse_result_df_pos<- timecourse_result_df
View(timecourse_60bin_result_df_vel)

timecourse_60bin_result_df_vel %>%
  ggplot(aes(timebins, t))+
  geom_line(size = 2)+
  geom_line(aes(y = p), linetype = "dashed", size = 2)+
  geom_hline(yintercept = .05, color = 'red', size = 1.5)

View(timecourse_60bin_result_df_vel)

range(timecourse_60bin_result_df_vel$Estimate_ar, na.rm = TRUE)
timecourse_60bin_result_df_vel %>%
  subset(!is.na(Estimate_ar))%>%
  ggplot(aes(timebins, Estimate_ar))+
  geom_line(size = 1)+
  geom_line(aes(y = Estimate_vl), linetype = "dashed", size = 1)+
  geom_line(aes(y = Estimate_br), linetype = "dotted", size = 1)+
  geom_line(aes(y = Estimate_ar_vl), linetype = "dotdash", size = 1, color = "red")+
  geom_hline(yintercept = 0.2)
  ylim(-.1,.25)
  
```

```{r}
# adjust p values and tag as TRUE whenevee there is at least 3 consecutive p values below .05

```


mutate(ANC=rollapply(ANC, width=3, max, align="left", fill=NA, na.rm=TRUE)) %>%
  filter(ANC >= 0.5) %>%  
  filter(row_number() == 1)
  
  
```{r}
timecourse_60bin_result_df_vel$p_ar_adj<- p.adjust(timecourse_60bin_result_df_vel$p_ar, method = "holm")
timecourse_60bin_result_df_vel$p_ar_adj_TRUE<- if_else(timecourse_60bin_result_df_vel$p_ar_adj<.05, TRUE, FALSE)


timecourse_60bin_result_df_vel$p_vl_adj <- p.adjust(timecourse_60bin_result_df_vel$p_vl, method = "holm")
timecourse_60bin_result_df_vel$p_vl_adj_TRUE<- if_else(timecourse_60bin_result_df_vel$p_vl_adj<.05, TRUE, FALSE)

timecourse_60bin_result_df_vel$p_br_adj <- p.adjust(timecourse_60bin_result_df_vel$p_br, method = "holm")
timecourse_60bin_result_df_vel$p_br_adj_TRUE<- if_else(timecourse_60bin_result_df_vel$p_br_adj<.05, TRUE, FALSE)

timecourse_60bin_result_df_vel$p_ar_vl_adj <- p.adjust(timecourse_60bin_result_df_vel$p_ar_vl, method = "holm")
timecourse_60bin_result_df_vel$p_ar_vl_adj_TRUE<- if_else(timecourse_60bin_result_df_vel$p_ar_vl_adj<.05, TRUE, NULL)

# find the first and last true in a sequence of TRUES
duplicated(timecourse_60bin_result_df_vel$p_ar_adj_TRUE, na.rm = TRUE)

# https://masterr.org/r/how-to-find-consecutive-repeats-in-r/
timecourse_60bin_result_df_vel$test<- NULL

timecourse_60bin_result_df_vel$test <- rle(timecourse_60bin_result_df_vel$p_ar < 0.05)
# View(runs)
# 
# runs[2]
# myruns = which(runs$values == TRUE & runs$lengths >= 3)

View(timecourse_60bin_result_df_vel)
```

```{r}

View(timecourse_60bin_result_df_vel)
#  let's use the order arousal, valence, arousal x valence brightness

plots_timecourse$eff_size_pup_velocity<-
timecourse_60bin_result_df_vel %>% 
  select("timebins","Estimate_ar", "Estimate_vl", "Estimate_br", "Estimate_ar_vl") %>% 
  pivot_longer(-timebins, names_to = "variable", values_to = "Estimate")%>%
    subset(!is.na(Estimate))%>%
  #change the order of the coloring variable here and the name of legends
  mutate(variable = factor(variable, c("Estimate_ar", "Estimate_vl","Estimate_ar_vl",  "Estimate_br"), labels = c("arousal", "valence", "arousal x valence", "brightness")))%>%
  ggplot(aes(timebins, Estimate, group = variable, color= variable))+
  geom_line(aes(linetype = variable), size = 1)+
  
  scale_color_brewer(palette = "Dark2")+
    # scale_color_manual(values=c("#1B9E77", "#D95F02", "#7570B3", "#E7298A"))+
  # use hom correction for significance
  
    # brighteness
    # timecourse_60bin_result_df_vel$timebins[timecourse_60bin_result_df_vel$p_br_adj_TRUE == TRUE]
  
    annotate(geom = 'rect', # use annotate instead of geom_rect, as it is more flexible
             xmin = .37, # got these values from the data-frame. need to fidn a way to automate this
                xmax = .81,
                ymin = -2.03+(sf*1.2), # if I ever need to change this, use the scaling factor sf
                ymax = -2+.1+.01+(sf*1.2),
                fill =  "#E7298A" , alpha = .5)+
    
      # annotate("text", 
      #           x = (1+5.4)/2,
      #           y = ((-2) +(-2+.1))/2+(sf*.3),
      #           label = "brightness") +
    
    # arousal
  
    # timecourse_60bin_result_df$p_ar_adj
      
    # timecourse_60bin_result_df_vel$timebins[timecourse_60bin_result_df_vel$p_ar_adj_TRUE == TRUE]
    
    # timecourse_60bin_result_df_vel$timebins
    
    annotate(geom = 'rect', 
              xmin = 1.028329,
                xmax = 1.028329+.1,
                ymin = -2.03+.1+.1+.1+.1+(sf*1.2),
                ymax = -2+.1+.1+.1+.1+.1+.01+(sf*1.2),
                fill = "#1B9E77", alpha = .5)+
        # annotate("text", 
        #           x = (1+5.4)/2,
        #         y = ((-2+.1+.1+.1+.1) +(-2+.1+.1+.1+.1+.1))/2+(sf*.3),
        #          label = "arousal") +

    # arousal-valence
   # timecourse_60bin_result_df$p_ar_vl_adj
    # timecourse_60bin_result_df_vel$timebins[timecourse_60bin_result_df_vel$p_ar_vl_adj_TRUE == TRUE]
       annotate(geom = 'rect', 
                xmin = 5.5730353,
                xmax = 5.5730353+.1,
                ymin = -2.03+.1+.1+(sf*1.2),
                ymax = -2+.1+.1+.1+.01+(sf*1.2),
                
                fill ="#7570B3", alpha = .5, label = "text")+
    
  # annotate("text", 
  #               x = (1+5.4)/2,
  #               y = ((-2+.1+.1) +(-2+.1+.1+.1))/2+(sf*.3),
  #               label = "arousal x valence") +
        xlab("Time (s)")+
    ylab("Effect size")+
    xlab("Time (s)")+
    ylab("Effect size")

plots_timecourse$eff_size_pup_velocity
# need to rename the label legends


# Edit legend title and labels
plots_timecourse$eff_size_pup_velocity

plots_timecourse$eff_size_pup_velocity<- plots_timecourse$eff_size_pup_velocity + 
  p$graphstyle +
    guides(colour = guide_legend(override.aes = list(size=2)))+ #the line size of the legend tends to be smaller in print
  scale_x_continuous(limits = c(0,6), breaks = c(0,2,4,6))+
  scale_y_continuous(limits = c(-1,1.5), breaks = c(-0.5, 0,0.5,1))
  

plots_timecourse$eff_size_pup_velocity
plots_timecourse$eff_size_pup_amp

```


velocity = actual velocity unlike speed (which is what I actually computed above. velocity encodes direction( constriction or dilation)


use the same datas timecourse to plot aggregated analyses
aggregate arousal plot
```{r}

db_full4new_stim_screen_pupil_nopract$ground_valence_2<-
  cut(db_full4new_stim_screen_pupil_nopract$ValenceMean, c(0,4,5,9), 
                                                              labels = c("negative", "neutral", "positive"))


db_full4new_stim_screen_pupil_nopract$sample_valence_lab2<-
  cut(db_full4new_stim_screen_pupil_nopract$ValenceMeanThisSample, c(-10,-3,3,10), 
                                                              labels = c("negative", "neutral", "positive"))



db_full4new_stim_screen_pupil_nopract$ground_arousal_2<-
  cut(db_full4new_stim_screen_pupil_nopract$ArousalMean, c(0,4,5,9), 
                                                              labels = c("low", "mid", "high"))

db_full4new_stim_screen_pupil_nopract$sample_arousal_lab2<-
  cut(db_full4new_stim_screen_pupil_nopract$ArousalMeanThisSample, c(-10,-3,3,10), 
                                                              labels = c("low", "mid", "high"))





subset(db_full4new_stim_screen_pupil_nopract, 
                                    pupil_outlier == FALSE & ssid_num<500 & 
                                      arousal_outler == FALSE)%>%
  ggplot(aes(sample_valence_lab2, arousal))+
  geom_point()+
  stat_summary(geom = 'pointrange')



subset(db_full4new_stim_screen_pupil_nopract, 
                                    pupil_outlier == FALSE & ssid_num<500 & 
                                      arousal_outler == FALSE)%>%
  group_by(ssid, mediansplit_ground_valence, mediansplit_ground_arousal)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(mediansplit_ground_valence, pup_resid_lm, color = mediansplit_ground_arousal ))+
  # geom_point()+
  stat_summary(geom = 'pointrange')
  


subset(db_full4new_stim_screen_pupil_nopract, 
                                    pupil_outlier == FALSE & ssid_num<500 & 
                                      arousal_outler == FALSE)%>%
  group_by(ssid, mediansplit_ground_valence, mediansplit_ground_arousal)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(mediansplit_ground_valence, pup_resid_lm, color = mediansplit_ground_arousal ))+
  # geom_point()+
  stat_summary(geom = 'pointrange')
  


plots_paper$interaction_ar_vl

# correlation plot

plots_paper$pupil_correlation <-   db_full4new_stim_screen_pupil_nopract %>%
  subset(Group == "NT")%>%
    # subset(ssid_num<500)%>%
  subset(pupil_outlier == FALSE & arousal_outler == FALSE)%>%
   group_by(ssid,Alexithymia, mediansplit_ground_valence)%>%
    mutate(cortest = cor.test(arousal_c, pup_basCor)$estimate)%>%
   group_by(ssid,Alexithymia, mediansplit_ground_valence)%>%
    summarise_if(is.numeric, mean, na.rm = TRUE)%>%
     ggplot(aes(mediansplit_ground_valence, cortest, fill = mediansplit_ground_valence))+
     geom_bar(stat="summary", fun.y = "mean", alpha = .5)+
     geom_jitter(width = .1, alpha = .1)+
        stat_summary( geom = 'pointrange')+
        stat_summary(aes(group = ssid), geom = 'line', alpha = .1)+
    ylab("R sujective vs pupil arousal")+
     scale_fill_brewer(palette = "Dark2")+
     p$graphstyle+
     theme(axis.title.x = element_blank())
   
plots_paper$pupil_correlation  




# timecourse plot pupil

tmp.df4_full_stim_downs_jun2021_60bins$sample_arousal_lab2<-
  cut(tmp.df4_full_stim_downs_jun2021_60bins$ArousalMeanThisSample, 3, 
                                                              labels = c("low", "mid", "high"))



tmp.df4_full_stim_downs_jun2021_60bins$sample_valence_lab2<-
  cut(tmp.df4_full_stim_downs_jun2021_60bins$ValenceMeanThisSample, 3 , 
                                                              labels = c("negative", "mid", "positive"))

tmp.df4_full_stim_downs_jun2021_60bins$newvalence <- if_else(tmp.df4_full_stim_downs_jun2021_60bins$sample_valence_lab2 == "mid" & tmp.df4_full_stim_downs_jun2021_60bins$sample_arousal_lab2 == "mid", "neutral", 
                                                             if_else(tmp.df4_full_stim_downs_jun2021_60bins$ValenceMeanThisSample> median(tmp.df4_full_stim_downs_jun2021_60bins$ValenceMeanThisSample, na.rm = TRUE), "positive", "negative")
                                                           )

table(tmp.df4_full_stim_downs_jun2021_60bins$newvalence)
unique(tmp.df4_full_stim_downs_jun2021_60bins$newvalence)

test<- tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num<500)%>%
  subset(!is.na(ground_arousal_lab))%>%
  # subset(stimIAPS!= "4573")%>%
  # subset(pupil_outlier == FALSE)%>%
  # subset(arousal_outler== FALSE)%>%
  group_by(mediansplit_sample_valence2)%>%
  mutate(mediantotes = median(ArousalMeanThisSample, na.rm = TRUE))%>%
  ungroup()%>%
  group_by(mediansplit_sample_valence2)%>%
  mutate(high_lowtes = if_else(arousal> mediantotes, "high", "low"))

tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num<500)%>%
  subset(!is.na(ground_arousal_lab))%>%
  # subset(stimIAPS!= "4573")%>%
  # subset(pupil_outlier == FALSE)%>%
  # subset(arousal_outler== FALSE)%>%
  # group_by(mediansplit_sample_valence2)%>%
  # mutate(mediantotes = median(ArousalMeanThisSample, na.rm = TRUE))%>%
  # ungroup()%>%
  # group_by(mediansplit_sample_valence2)%>%
  # mutate(high_lowtes = if_else(arousal> mediantotes, "high", "low")) %>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  # stat_summary(geom = 'pointrange')+
    # facet_grid(~mediansplit_self_valence)
  
  # stat_smooth(aes(group= stimIAPS, color = sample_arousal_lab2), fun = mean,
               # se = F, alpha = .15, size = 1.5)+
  stat_smooth(aes(group=sample_arousal_lab2, color = sample_arousal_lab2), size = 3)+
  # stat_summary(aes(group=stimIAPS, color = high_lowtes), fun = mean, geom = "pointrange")+
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # geom_text(aes(label = stimIAPS))+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")


tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num<500)%>%
  subset(!is.na(ground_arousal_lab))%>%
  # subset(stimIAPS!= "4573")%>%
  # subset(pupil_outlier == FALSE)%>%
  # subset(arousal_outler== FALSE)%>%
  # group_by(mediansplit_sample_valence2)%>%
  # mutate(mediantotes = median(ArousalMeanThisSample, na.rm = TRUE))%>%
  # ungroup()%>%
  # group_by(mediansplit_sample_valence2)%>%
  # mutate(high_lowtes = if_else(arousal> mediantotes, "high", "low")) %>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  # stat_summary(geom = 'pointrange')+
    # facet_grid(~mediansplit_self_valence)
  
  # stat_smooth(aes(group= stimIAPS, color = sample_valence_lab2), fun = mean,
  #              se = F, alpha = .15, size = 1.5)+
  stat_smooth(aes(group=newvalence, color = newvalence), size = 3)+
  # stat_summary(aes(group=stimIAPS, color = high_lowtes), fun = mean, geom = "pointrange")+
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # geom_text(aes(label = stimIAPS))+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")
  facet_grid(~newvalence)

```
  # xlim(0,6)+
  facet_grid(~mediansplit_sample_valence2)
```{r}
# plot separatelly




test<- tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num<500)%>%
  subset(!is.na(ground_arousal_lab))%>%
  # subset(stimIAPS!= "4573")%>%
  # subset(pupil_outlier == FALSE)%>%
  # subset(arousal_outler== FALSE)%>%
  group_by(mediansplit_sample_valence2)%>%
  mutate(mediantotes = median(ArousalMeanThisSample, na.rm = TRUE))%>%
  ungroup()%>%
  group_by(mediansplit_sample_valence2)%>%
  mutate(high_lowtes = if_else(arousal> mediantotes, "high", "low"))

tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num<500)%>%
  subset(!is.na(ground_arousal_lab))%>%
  # subset(stimIAPS!= "4573")%>%
  # subset(pupil_outlier == FALSE)%>%
  # subset(arousal_outler== FALSE)%>%
  # group_by(mediansplit_sample_valence2)%>%
  # mutate(mediantotes = median(ArousalMeanThisSample, na.rm = TRUE))%>%
  # ungroup()%>%
  # group_by(mediansplit_sample_valence2)%>%
  # mutate(high_lowtes = if_else(arousal> mediantotes, "high", "low")) %>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  # stat_summary(geom = 'pointrange')+
    # facet_grid(~mediansplit_self_valence)
  
  # stat_smooth(aes(group= stimIAPS, color = sample_arousal_lab2), fun = mean,
  #              se = F, alpha = .15, size = 1.5)+
  stat_smooth(aes(group=sample_arousal_lab2, color = sample_arousal_lab2), size = 3)+
  # stat_summary(aes(group=stimIAPS, color = high_lowtes), fun = mean, geom = "pointrange")+
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # geom_text(aes(label = stimIAPS))+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")
  # xlim(0,6)+
  facet_grid(~mediansplit_sample_valence2)
  
  
  tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num<500)%>%
  subset(!is.na(ground_arousal_lab))%>%
  # subset(stimIAPS!= "4573")%>%
  # subset(pupil_outlier == FALSE)%>%
  # subset(arousal_outler== FALSE)%>%
  # group_by(mediansplit_sample_valence2)%>%
  # mutate(mediantotes = median(ArousalMeanThisSample, na.rm = TRUE))%>%
  # ungroup()%>%
  # group_by(mediansplit_sample_valence2)%>%
  # mutate(high_lowtes = if_else(arousal> mediantotes, "high", "low")) %>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  # stat_summary(geom = 'pointrange')+
    # facet_grid(~mediansplit_self_valence)
  
  # stat_smooth(aes(group= stimIAPS, color = sample_arousal_lab2), fun = mean,
  #              se = F, alpha = .15, size = 1.5)+
  stat_smooth(aes(group=sample_arousal_lab2, color = sample_arousal_lab2), size = 3)+
  # stat_summary(aes(group=stimIAPS, color = high_lowtes), fun = mean, geom = "pointrange")+
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # geom_text(aes(label = stimIAPS))+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")


# negative

tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num<500)%>%
  subset(!is.na(ground_arousal_lab))%>%
  subset(mediansplit_sample_valence2 != "More negative")%>%
  mutate(mediantotes = median(arousal, na.rm = TRUE))%>%
  ungroup()%>%
  mutate(high_lowtes = if_else(arousal> mediantotes, "high", "low")) %>%
  ggplot(aes(x = timerezero3, y = pup_basCor))+
  # stat_smooth(aes(group= stimIAPS), fun = mean,
               # se = F, alpha = .15, size = 1.5)+
  geom_smooth(aes(group = high_lowtes))+
  # stat_smooth(fun = mean,
  #              se = F, alpha = .15, size = 3)+
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # geom_text(aes(label = stimIAPS))+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")
  # xlim(0,6)+
  facet_grid(~ high_lowtes)+
  geom_hline(yintercept = 0)+
  geom_hline(yintercept = -0.5)

  
```


# start wit aggregate()

# tmp.df4_full_stim_downs_jun2021_60bins%>%


tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num<500)%>%
  subset(!is.na(ground_arousal_lab))%>%
  subset(stimIAPS!= "4573")%>%
  subset(pupil_outlier == FALSE)%>%
  group_by(stimIAPS,stimDescription, mediansplit_sample_arousal2, mediansplit_sample_valence2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
    group_by(mediansplit_sample_valence2)%>%
  mutate(high_lowtes = if_else(arousal> median(arousal, na.rm = TRUE), "high", "low"))%>%
  ggplot(aes(x =high_lowtes , y = pup_basCor))+
  stat_summary(geom = 'pointrange')+
  facet_grid(~mediansplit_sample_valence2)+
  geom_text(aes(label = stimDescription))


tmp.df4_full_stim_downs_jun2021_60bins %>%
  subset(ssid_num<500)%>%
  subset(!is.na(ground_arousal_lab))%>%
  subset(stimIAPS!= "4573")%>%
  subset(pupil_outlier == FALSE)%>%
  group_by(stimIAPS,stimDescription, mediansplit_sample_arousal2, mediansplit_sample_valence2)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
    group_by(mediansplit_sample_valence2)%>%
  mutate(high_lowtes = if_else(arousal> median(arousal, na.rm = TRUE), "high", "low"))%>%
  ggplot(aes(x =high_lowtes , y = Mean_gray_z))+
  stat_summary(geom = 'pointrange')+
  facet_grid(~mediansplit_sample_valence2)+
  geom_text(aes(label = stimDescription))
    # facet_grid(~mediansplit_self_valence)
  # stat_smooth(aes(group= stimIAPS, color = sample_arousal_lab2), fun = median,geom = "line",
               # se = F, alpha = .1, size = 1.5)+
  stat_smooth(aes(group=mediansplit_sample_arousal2, color = mediansplit_sample_arousal2), size = 3)+
  # stat_summary(aes(group=sample_arousal_lab2, color = sample_arousal_lab2), fun = mean, geom = "pointrange")+
theme_classic()+
  ylab("Pupil size (z)")+
  xlab("Time (s)")+
  # geom_text(aes(label = stimIAPS))+
  # p$graphstyle+
  scale_color_brewer(palette = "Dark2")+
  xlim(0,6)+
  facet_grid(~mediansplit_self_valence)



```{r}
# let's test the interaction term
nbins<- unique(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)
range(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)

unique(tmp.df4_full_stim_downs_jun2021_60bins$timebin_no)

# nbins = 60 # number of bins

# create and empty dataframe for the timecourse analyses
timecourse_60bin_result_df_vel_dir <- data.frame(timebins= rep(NA, 60), 
                                       Estimate_ar= rep(NA, 60), 
                                       t_ar=rep(NA, 60), 
                                       p_ar=rep(NA, 60),
                                       Estimate_vl= rep(NA, 60), 
                                       t_vl=rep(NA, 60), 
                                       p_vl=rep(NA, 60),
                                       Estimate_br= rep(NA, 60), 
                                       t_br=rep(NA, 60), 
                                       p_br=rep(NA, 60),
                                       Estimate_ar_vl= rep(NA, 60), 
                                       t_ar_vl=rep(NA, 60), 
                                       p_ar_vl=rep(NA, 60),
                                       cov= as.character(rep(NA,60)))


i = 0 # remember to always rezero it
# rm(i,b)

# i =1

for (b in 3:length(nbins)) {
  # for (s in 1:length(nsim)) {

    message(sprintf("$$$$$RUNING lmer %i", nbins[b]))
        lmer_bin_pup  <- lmer(pup_velocity_dir ~ (arousal_c* valence)+Mean_gray_z  +
                                (1 | ssid),
                                # (0 +arousal_c* valence | ssid),
                                # (1|stimIAPS),
                              REML = FALSE,
                      data = subset(tmp.df4_full_stim_downs_jun2021_60bins,
                                    ssid_num< 500&
                                    !is.na(pup_vel_smooth) &
                                    timebin_no == nbins[b]))

        # store results from the simulation
            lmer_bin_pup_summary<- summary(lmer_bin_pup)
            lmer_bin_pup_summary
            # lmer_bin_pup_summary[["coefficients"]][3,1]
            timecourse_60bin_result_df_vel_dir[i,1]<- tmp.df4_full_stim_downs_jun2021_60bins$timerezero3[b] 
            #save the exact value of time bin
            # store arousal (2,parameter)            # first number is term(row), second is column
            timecourse_60bin_result_df_vel_dir[i,2]<-
            lmer_bin_pup_summary[["coefficients"]][2,1] #estimate
            timecourse_60bin_result_df_vel_dir[i,3]<-
              lmer_bin_pup_summary[["coefficients"]][2,4] # t statistic
            timecourse_60bin_result_df_vel_dir[i,4]<-
            lmer_bin_pup_summary[["coefficients"]][2,5] # p value
            
            # valence
            
            timecourse_60bin_result_df_vel_dir[i,5]<-
            lmer_bin_pup_summary[["coefficients"]][3,1] #estimate
            timecourse_60bin_result_df_vel_dir[i,6]<-
              lmer_bin_pup_summary[["coefficients"]][3,4] # t statistic
            timecourse_60bin_result_df_vel_dir[i,7]<-
              lmer_bin_pup_summary[["coefficients"]][3,5] # p value
            
            # brightness
            
            timecourse_60bin_result_df_vel_dir[i,8]<-
            lmer_bin_pup_summary[["coefficients"]][4,1] #estimate
            timecourse_60bin_result_df_vel_dir[i,9]<-
              lmer_bin_pup_summary[["coefficients"]][4,4] # t statistic
            timecourse_60bin_result_df_vel_dir[i,10]<-
              lmer_bin_pup_summary[["coefficients"]][4,5] # p value
            
            # interaction arousal x brighteness
            
            timecourse_60bin_result_df_vel_dir[i,11]<-
            lmer_bin_pup_summary[["coefficients"]][5,1] #estimate
            timecourse_60bin_result_df_vel_dir[i,12]<-
              lmer_bin_pup_summary[["coefficients"]][5,4] # t statistic
            timecourse_60bin_result_df_vel_dir[i,13]<-
              lmer_bin_pup_summary[["coefficients"]][5,5] # p value
            
            
            timecourse_60bin_result_df_vel_dir[i,14] <-
              ifelse(length(lmer_bin_pup_summary$optinfo$conv$lme4$message)
                                                   != 0,
                                               lmer_bin_pup_summary$optinfo$conv$lme4$message, 'pass')

     i = i+1
}
# timecourse_result_df_pos<- timecourse_result_df
View(timecourse_60bin_result_df_vel_dir)

View(timecourse_60bin_result_df_vel_dir)

timecourse_60bin_result_df_vel_dir %>%
  ggplot(aes(timebins, Estimate_ar))+
  geom_line(size = 1)+
  geom_line(aes(y = Estimate_vl), linetype = "dashed", size = 1)+
  geom_line(aes(y = Estimate_br), linetype = "dotted", size = 1)+
  geom_line(aes(y = Estimate_ar_vl), linetype = "dotdash", size = 1, color = "red")
  ylim(-.1,5)
  
  
# adjust p values and tag as TRUE whenevee there is at least 3 consecutive p values below .05
?p.adjust
timecourse_60bin_result_df_vel_dir$p_ar_adj<- p.adjust(timecourse_60bin_result_df_vel_dir$p_ar, method = "holm")
timecourse_60bin_result_df_vel_dir$p_ar_adj_TRUE<- if_else(timecourse_60bin_result_df_vel_dir$p_ar_adj<.05, TRUE, FALSE)


timecourse_60bin_result_df_vel_dir$p_vl_adj <- p.adjust(timecourse_60bin_result_df_vel_dir$p_vl, method = "holm")
timecourse_60bin_result_df_vel_dir$p_vl_adj_TRUE<- if_else(timecourse_60bin_result_df_vel_dir$p_vl_adj<.05, TRUE, FALSE)

timecourse_60bin_result_df_vel_dir$p_br_adj <- p.adjust(timecourse_60bin_result_df_vel_dir$p_br, method = "holm")
timecourse_60bin_result_df_vel_dir$p_br_adj_TRUE<- if_else(timecourse_60bin_result_df_vel_dir$p_br_adj<.05, TRUE, FALSE)

timecourse_60bin_result_df_vel_dir$p_ar_vl_adj <- p.adjust(timecourse_60bin_result_df_vel_dir$p_ar_vl, method = "holm")
timecourse_60bin_result_df_vel_dir$p_ar_vl_adj_TRUE<- if_else(timecourse_60bin_result_df_vel_dir$p_ar_vl_adj<.05, TRUE, NULL)

# find the first and last true in a sequence of TRUES
duplicated(timecourse_60bin_result_df_vel_dir$p_ar_adj_TRUE, na.rm = TRUE)

# https://masterr.org/r/how-to-find-consecutive-repeats-in-r/
timecourse_60bin_result_df_vel_dir$test<- NULL

timecourse_60bin_result_df_vel_dir$test <- rle(timecourse_60bin_result_df_vel_dir$p_ar < 0.05)
```



SCR
```{r}

db_full4new_stim_screen_pupil_nopract_nt<- subset(db_full4new_stim_screen_pupil_nopract, Group == "NT")

unique(db_full4new_stim_screen_pupil_nopract_nt$screencontent)
db_full4new_stim_screen_pupil_nopract_nt_304<- subset(db_full4new_stim_screen_pupil_nopract_nt, ssid_num>303)

db_full4new_stim_screen_pupil_nopract_nt_304

db_full4new_stim_screen_pupil_nopract_nt_304<- db_full4new_stim_screen_pupil_nopract_nt_304%>%
  ungroup%>%
  mutate(valence_c = scale(valence, center = TRUE, scale = TRUE)[,1])%>%
  mutate(arousal_c = scale(arousal, center = TRUE, scale = TRUE)[,1])%>%
  mutate(TASc = scale(TAS, center = TRUE, scale = TRUE)[,1])

# models
table(is.na(db_full4new_stim_screen_pupil_nopract_nt_304$BIO_CDA.SCR))

pupil_arousal_findings$arousal_scr <- lmer(log(BIO_CDA.SCR+.1) ~ arousal_c*valence_c +
                                             (1|ssid) + (1|stimIAPS),
                        REML = FALSE,
                        data = subset(db_full4new_stim_screen_pupil_nopract_nt_304))

summary(pupil_arousal_findings$arousal_scr)

interactions::interact_plot(pupil_arousal_findings$arousal_scr, pred = arousal_c, modx = valence_c)


# arousal_BIO_CDA.AmpSum
pupil_arousal_findings$arousal_BIO_CDA.AmpSum <- lmer(log(BIO_CDA.AmpSum+.1) ~ arousal_c*valence_c +
                                             (1|ssid) + (1|stimIAPS),
                        REML = FALSE,
                        data = subset(db_full4new_stim_screen_pupil_nopract_nt_304))

summary(pupil_arousal_findings$arousal_BIO_CDA.AmpSum)

interactions::interact_plot(pupil_arousal_findings$arousal_BIO_CDA.AmpSum, pred = arousal_c, modx = valence_c)


# BIO_CDA.ISCR
pupil_arousal_findings$BIO_CDA.ISCR <- lmer(log(BIO_CDA.ISCR+.1) ~ arousal_c*valence_c +
                                             (1+valence_c|ssid) + (1|stimIAPS),
                        REML = FALSE,
                        data = subset(db_full4new_stim_screen_pupil_nopract_nt_304))

summary(pupil_arousal_findings$BIO_CDA.ISCR)

interactions::interact_plot(pupil_arousal_findings$BIO_CDA.ISCR, pred = arousal_c, modx = valence_c)


# phasic
unique(db_full4new_stim_screen_pupil_nopract_nt_304$ssid)

db_full4new_stim_screen_pupil_nopract_nt_304$arousal_abs<- abs(db_full4new_stim_screen_pupil_nopract_nt_304$arousal)

db_full4new_stim_screen_pupil_nopract_nt_304$arousal_abs_z<- scale(db_full4new_stim_screen_pupil_nopract_nt_304$arousal_abs, center = TRUE,scale = TRUE)

pupil_arousal_findings$BIO_CDA.PhasicMax <- lmer(log1p(BIO_CDA.PhasicMax+.1) ~ arousal_c * valence_c + (1|ssid) + (1|stimIAPS),
                        REML = FALSE,
                        data = db_full4new_stim_screen_pupil_nopract_nt_304)

summary(pupil_arousal_findings$BIO_CDA.PhasicMax)

sjplot::tab_model(pupil_arousal_findings$BIO_CDA.PhasicMax)
anova(pupil_arousal_findings$arousal_phas_max)
interactions::interact_plot(pupil_arousal_findings$BIO_CDA.PhasicMax, pred = arousal_c, modx = valence_c)


```

```{r}
unique(db_full4new_stim_screen_pupil_nopract_nt_304$ssid)

db_full4new_stim_screen_pupil_nopract_nt_304$stimIAPS2<- as.character(substr(db_full4new_stim_screen_pupil_nopract_nt_304$stimIAPS, 1,4))


nrow(db_full4new_stim_screen_pupil_nopract_nt_304)
nrow(testmatched_scr)
testmatched_scr<- right_join(macthed_test, db_full4new_stim_screen_pupil_nopract_nt_304, by = "stimIAPS2")

testmcthedscr <- lmer(log1p(BIO_CDA.PhasicMax+.1) ~ arousal_c * valence_c + (1|ssid) + (1|stimIAPS),
                        REML = FALSE,
                        data = testmatched_scr)

summary(testmcthedscr)

anova(pupil_arousal_findings$arousal_phas_max)

interactions::interact_plot(testmcthedscr, pred = arousal_c, modx = valence_c)

```

```
pupil_arousal_findings$BIO_CDA.PhasicMax_ar <- lmer(log1p(BIO_CDA.PhasicMax+.1) ~ arousal_c + (1|ssid),
                        REML = FALSE,
                        data = db_full4new_stim_screen_pupil_nopract_nt_304)

interactions::interact_plot(pupil_arousal_findings$BIO_CDA.PhasicMax, pred =valence_c , modx =  arousal_c)

summary(pupil_arousal_findings$BIO_CDA.PhasicMax_ar)
pupil_arousal_findings$BIO_CDA.PhasicMax_vl <- lmer(log1p(BIO_CDA.PhasicMax+.1) ~ valence_c + (1|ssid) + (1|stimIAPS),
                        REML = FALSE,
                        data = db_full4new_stim_screen_pupil_nopract_nt_304)

interactions::interact_plot(pupil_arousal_findings$BIO_CDA.PhasicMax, pred =valence_c , modx =  arousal_c)

summary(pupil_arousal_findings$BIO_CDA.PhasicMax_vl)


```

semi matched dataset
```


# deal with colinearity by swicthing predictor to dv

db_full4new_stim_screen_pupil_nopract_nt_304$log1p_BIO_CDA.PhasicMax <- log1p(db_full4new_stim_screen_pupil_nopract_nt_304$BIO_CDA.PhasicMax+.1)

db_full4new_stim_screen_pupil_nopract_nt_304$log1p_BIO_CDA.PhasicMax_z<- scale(db_full4new_stim_screen_pupil_nopract_nt_304$log1p_BIO_CDA.PhasicMax, center = TRUE, scale = TRUE)[,1]


pupil_arousal_findings$ar_BIO_CDA.PhasicMax <- lmer(arousal_c ~ valence_c +log1p_BIO_CDA.PhasicMax_z+ (1|ssid)+(1|stimIAPS),
                        REML = FALSE,
                        data = db_full4new_stim_screen_pupil_nopract_nt_304)

summary(pupil_arousal_findings$ar_BIO_CDA.PhasicMax)


pupil_arousal_findings$ar_BIO_CDA.PhasicMax <- lmer( valence_c~ arousal_c+log1p_BIO_CDA.PhasicMax_z+ (1|ssid)+(1|stimIAPS),
                        REML = FALSE,
                        data = db_full4new_stim_screen_pupil_nopract_nt_304)

summary(pupil_arousal_findings$ar_BIO_CDA.PhasicMax)





# Global
unique(db_full4new_stim_screen_pupil_nopract_nt_304$ssid)

pupil_arousal_findings$BIO_Global.Mean <- lmer(log1p(BIO_Global.Mean+.1) ~ arousal_c * valence_c + (1|ssid)+ (1|stimIAPS),
                        REML = FALSE,
                        data = db_full4new_stim_screen_pupil_nopract_nt_304)

# TTP
table(is.na(db_full4new_stim_screen_pupil_nopract_nt_304$BIO_TTP.AmpSum))
pupil_arousal_findings$BIO_TTP.AmpSum <- lmer(log1p(BIO_TTP.AmpSum+.1) ~ arousal_c * valence_c + (1|ssid)+ (1|stimIAPS),
                        REML = FALSE,
                        data = db_full4new_stim_screen_pupil_nopract_nt_304)

summary(pupil_arousal_findings$BIO_TTP.AmpSum)


anova(pupil_arousal_findings$arousal_phas_max)
interactions::interact_plot(pupil_arousal_findings$BIO_CDA.PhasicMax, pred = arousal_c, modx = valence_c)

interactions::interact_plot(pupil_arousal_findings$BIO_CDA.PhasicMax, pred =valence_c , modx =  arousal_c)



# alexithymia
table(is.na(db_full4new_stim_screen_pupil_nopract_nt_304$BIO_CDA.PhasicMax))
interactions::interact_plot(pupil_arousal_findings$BIO_CDA.PhasicMax, pred = arousal_c, modx = valence_c)
pupil_arousal_findings$BIO_CDA.ISCR_TAS <- lmer(log(BIO_CDA.AmpSum +.1) ~ arousal_c+
                                             (1|ssid) + (1|stimIAPS),
                        REML = FALSE,
                        data = subset(db_full4new_stim_screen_pupil_nopract_nt_304$gsr_basCor))
summary(pupil_arousal_findings$BIO_CDA.ISCR_TAS)

# table(is.na(db_full4new_stim_screen_pupil_nopract_nt_304

# collapsed
```


Heart rate

```{r}

# keep stim and and fixation
unique(db_full6new$screencontent)
unique(db_full6new$screencontent_no)
colnames(db_full6new)

# 345:355
library(readr)
library(readr)
 # read_csv("tmp.df4_sum_full_bio_hr_self_parsed_345_356.csv")
View(tmp_df4_sum_full_bio_hr_self_parsed_345_356)

colnames(db_HR_bio_final_346_355_withfix)

# tmp.df4_sum_full_bio_hr_self_parsed_345_356.csv
db_HR_bio_final_346_355_withfix <-  read_csv("tmp.df4_sum_full_bio_hr_self_parsed_345_356.csv")
View(db_HR_bio_final_346_355_withfix)

db_HR_bio_final_346_355_withfix$screencontent<- db_HR_bio_final_346_355_withfix$screen_content
db_HR_bio_final_346_355_withfix<- subset(db_HR_bio_final_346_355_withfix, tNo > -7)

db_HR_bio_final_346_355_withfix$screencontent_no<- if_else(db_HR_bio_final_346_355_withfix$screen_content == "fixation", 1,
                                                           if_else(db_HR_bio_final_346_355_withfix$screen_content == "stim", 2,
                                                                   if_else(db_HR_bio_final_346_355_withfix$screen_content == "valence", 3, 4)))

db_HR_bio_final_346_355_withfix_stim <- subset(db_HR_bio_final_346_355_withfix, screencontent_no<3)


# 
# db_HR_bio_final_346_355_withfix_stim$tNo<- db_HR_bio_final_346_355_withfix_stim$tNo3
unique(db_HR_bio_final_346_355_withfix$tNo)
unique(db_HR_bio_final_346_355_withfix$tNo)

db_HR_bio_final_346_355_withfix_stim$tNo2<-NULL

db_HR_bio_final_346_355_withfix_stim$tNo3<- NULL

unique(db_HR_bio_final_346_355_withfix$screencontent)
unique(db_full6new_hr_fix_stim$screencontent)
# db_HR_bio_final_346_355_withfix$screencontent_no<- 


colnames(db_full6new)

db_full6new$bio_cda.n
db_full6new_hr_fix_stim <- subset(db_full6new, screencontent_no <3)

View(db_full6new_hr_fix_stim)
# fixation"    "stim" 
colnames(db_full6new_hr_fix_stim)
colnames(db_HR_bio_final_346_355_withfix_stim)

db_HR_bio_final_346_355_withfix_stim$Bio_Mean_HR<- db_HR_bio_final_346_355_withfix_stim$Mean_HR

db_HR_bio_final_346_355_withfix_stim$ssid_num<- as.numeric(db_HR_bio_final_346_355_withfix_stim$ssid)
# keep controls
unique(db_full6new_hr_fix_stim$ssid)
db_full6new_hr_fix_stim$ssid_num <- as.numeric(as.character(db_full6new_hr_fix_stim$ssid))



table(is.na(db_full6new_hr_fix_stim))

db_full6new_hr_fix_stim$Group<- if_else(db_full6new_hr_fix_stim$ssid_num< 500, "NT",
                                        if_else(db_full6new_hr_fix_stim$ssid_num>700, "NT",
                                                "ASC"))

table(is.na(db_full6new_hr_fix_stim$Group))

db_full6new_hr_fix_stim$bio_cda.n
db_full6new_hr_fix_stim_nt<- subset(db_full6new_hr_fix_stim, Group == "NT")
unique(db_full6new_hr_fix_stim_nt$ssid_num)

# attention
db_full6new_hr_fix_stim_nt<- subset(db_full6new_hr_fix_stim_nt, ssid_num> 303)
unique(db_full6new_hr_fix_stim_nt$ssid)
colnames(db_full6new_hr_fix_stim_nt)

# HR differences
db_full6new_hr_fix_stim_nt$Bio_Mean_HR_fix<- if_else(db_full6new_hr_fix_stim_nt$screencontent_no ==1, db_full6new_hr_fix_stim_nt$Bio_Mean_HR, NULL)

table(is.na(db_HR_bio_final_346_355_withfix_stim$BIO_CDA.nSCR))

unique(db_HR_bio_final_346_355_withfix_stim$ssid)
db_HR_bio_final_346_355_withfix_stim$Bio_Mean_HR_fix<- if_else(db_HR_bio_final_346_355_withfix_stim$screencontent_no ==1, db_HR_bio_final_346_355_withfix_stim$Bio_Mean_HR, NULL)

View(db_full6new_hr_fix_stim_nt)
View(db_HR_bio_final_346_355_withfix_stim)

db_HR_bio_final_346_355_withfix_stim$Mean_HR<- NULL

db_HR_bio_final_346_355_withfix_stim$ssid<- as.character(db_HR_bio_final_346_355_withfix_stim$ssid)


db_HR_bio_final_346_355_withfix_stim$tNo <- db_HR_bio_final_346_355_withfix_stim$tNo3.x
unique(db_HR_bio_final_346_355_withfix_stim$tNo)

db_HR_bio_final_346_355_withfix_stim$tNo <- as.character(db_HR_bio_final_346_355_withfix_stim$tNo)
db_HR_bio_final_346_355_withfix_stim$trigger <- as.character(db_HR_bio_final_346_355_withfix_stim$trigger)

db_full6new_hr_fix_stim_nt$trigger<- as.character(db_full6new_hr_fix_stim_nt$trigger)
db_full6new_hr_fix_stim_nt$trigger.x<- NULL

# db_HR_bio_final_346_355_withfix_stim$trig <- as.character(db_HR_bio_final_346_355_withfix_stim$tNo)

# db_HR_bio_final_346_355_withfix_stim$triger<- NULL
db_HR_bio_final_346_355_withfix_stim$trigger.x<- NULL

db_HR_bio_final_346_355_withfix_stim$trigger.y<- NULL
db_HR_bio_final_346_355_withfix_stim$trigger2<- NULL
db_HR_bio_final_346_355_withfix_stim$trigger_200<- NULL

nrow(db_full6new_hr_fix_stim_nt)+ nrow(db_HR_bio_final_346_355_withfix_stim)
# 6895
# nrow(bind_rows(db_full6new_hr_fix_stim_nt, db_HR_bio_final_346_355_withfix_stim))
db_HR_bio_final_346_355_withfix_stim$Bio_Mean_HR_fix

colnames(db_HR_bio_final_346_355_withfix_stim)
as.factor(db_HR_bio_final_346_355_withfix_stim$stimIAPS)
db_full6new_hr_fix_stim_nt$stimIAPS

db_HR_bio_final_346_355_withfix_stim

as.factor(db_HR_bio_final_346_355_withfix_stim$stim.x)
as.factor(db_HR_bio_final_346_355_withfix_stim$stim.y)
db_HR_bio_final_346_355_withfix_stim$stim.y<- NULL

unique(db_HR_bio_final_346_355_withfix_stim$screencontent)
unique(db_full6new_hr_fix_stim_nt$screencontent)
unique(db_full6new_hr_fix_stim_nt$screencontent.y)

db_full6new_hr_fix_stim_nt$screencontent.x<- NULL
db_full6new_hr_fix_stim_nt$screencontent.y<- NULL

unique(db_full6new_hr_fix_stim_nt$trialUnq.x)
unique(db_full6new_hr_fix_stim_nt$trialUnq.y)

db_full6new_hr_fix_stim_nt$trialUnq<- db_full6new_hr_fix_stim_nt$trialUnq.x
db_full6new_hr_fix_stim_nt$trialUnq.y<- NULL
db_full6new_hr_fix_stim_nt$trialUnq.x<- NULL


db_HR_bio_final_346_355_withfix_stim$stim<- db_HR_bio_final_346_355_withfix_stim$stim.x
# db_HR_bio_final_346_355_withfix_stim$stim<- db_HR_bio_final_346_355_withfix_stim$stim.x

# bind heartrate old and new
table(is.na(db_HR_bio_final_346_355_withfix_stim$Bio_Mean_HR))
table(is.na(db_full6new_hr_fix_stim_nt$Bio_Mean_HR))
test<- subset(db_full6new_hr_fix_stim_nt, is.na(Bio_Mean_HR))
test1<- subset(db_HR_bio_final_346_355_withfix_stim, is.na(Bio_Mean_HR))

db_full6new_hr_fix_stim_nt$bio_cda.
db_full6new_hr_fix_stim_nt1<- bind_rows(db_full6new_hr_fix_stim_nt,
                                        db_HR_bio_final_346_355_withfix_stim)



unique(db_full6new_hr_fix_stim_nt$Group)

# 346 missing praticdata - it was processed wrongly
# 347 missing



library(dplyr)
library(tidyverse)

table(is.na(db_full6new_hr_fix_stim_nt1$Bio_Mean_HR))

test<- subset(db_full6new_hr_fix_stim_nt1, is.na(Bio_Mean_HR))

unique(test$ssid)
# 606 

# 348 to 355 are missing pratice
table(is.na(db_full6new_hr_fix_stim_nt1$BIO_CDA.nSCR))

db_full6new_hr_fix_stim_nt1.1<- db_full6new_hr_fix_stim_nt1 %>%
  # mutate()
  group_by(as.numeric(ssid_num), as.numeric(tNo)) %>%
  arrange(ssid_num, as.numeric(tNo),as.numeric(screencontent_no))%>%
  # select(ssid, tNo,screencontent_no, Bio_Mean_HR,Bio_Mean_HR_fix)
  fill(Bio_Mean_HR_fix, .direction = "down")%>%
  subset(screencontent_no == 2)

View(db_full6new_hr_fix_stim_nt1.1)

# 2 1
# stim - fix = positive stim> neg stim<
db_full6new_hr_fix_stim_nt1.1<- db_full6new_hr_fix_stim_nt1.1 %>%
  mutate(Bio_Mean_HR_dif = Bio_Mean_HR - Bio_Mean_HR_fix)



db_full6new_hr_fix_stim_nt1.1%>%
  ggplot(aes(Bio_Mean_HR_dif))+
  geom_histogram()

?scatter3d 


db_full6new_hr_fix_stim_nt1.1%>%
  subset(!is.na(pup_basCor))%>%
   subset(!is.na(BIO_CDA.PhasicMax))%>%
  subset(!is.na(Bio_Mean_HR_dif))


db_full6new_hr_fix_stim_nt1<- db_full6new_hr_fix_stim_nt1%>%
  group_by(ssid)%>%
  mutate(BIO_CDA.PhasicMax_z= scale(BIO_CDA.PhasicMax, center = TRUE, scale = TRUE)[,1])

car::scatter3d(x = db_full6new_hr_fix_stim_nt1.1$pup_basCor, 
          y = db_full6new_hr_fix_stim_nt1.1$BIO_CDA.PhasicMax_z, 
          z = db_full6new_hr_fix_stim_nt1.1$Bio_Mean_HR_dif, 
          fit = "smooth",
          
          surface = FALSE,
          point.col = "blue",
          # point
          groups = as.factor(db_full6new_hr_fix_stim_nt1.1$mediansplit_ground_arousal),
          ellipsoid = TRUE)



cor(db_full6new_hr_fix_stim_nt1[,c("pup_basCor", "BIO_CDA.PhasicMax_z","Bio_Mean_HR_dif")], use = "complete")



db_full6new_hr_fix_stim_nt1%>%
  group_by(ssid,mediansplit_ground_valence)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(pup_basCor,BIO_CDA.PhasicMax_z, color= mediansplit_ground_valence))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  ylim(0,.4)+
  ggpubr::stat_cor()



db_full6new_hr_fix_stim_nt1%>%
  # group_by(ssid)%>%
  # mutate(Bio_Mean_HR_dif_z = scale(Bio_Mean_HR_dif))
  group_by(ssid,mediansplit_ground_valence)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(pup_basCor,Bio_Mean_HR_dif_z, color= mediansplit_ground_valence))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  # ylim(-7,2)+
  ggpubr::stat_cor()



db_full6new_hr_fix_stim_nt1%>%
  subset(!is.na(mediansplit_ground_valence))%>%
  # group_by(ssid)%>%
  # mutate(Bio_Mean_HR_dif_z = scale(Bio_Mean_HR_dif))
  group_by(ssid,mediansplit_ground_valence)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(BIO_CDA.PhasicMax_z,Bio_Mean_HR_dif, color= mediansplit_ground_valence))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  # ylim(-7,2)+
  ggpubr::stat_cor()+
  facet_grid(~mediansplit_ground_valence)
  

```


```{r}

unique(db_full6new_hr_fix_stim_nt1.1$screencontent_no)

test<- subset(db_full6new_hr_fix_stim_nt1.1, is.na(Bio_Mean_HR_dif))

unique(test$ssid)

db_full6new_hr_fix_stim_nt1.1$Bio_Mean_HR_dif_outl <- if_else(abs(db_full6new_hr_fix_stim_nt1.1$Bio_Mean_HR_dif)>                                                   (median(abs(db_full6new_hr_fix_stim_nt1.1$Bio_Mean_HR_dif),na.rm = TRUE) +                                                               (4*(sd(abs(db_full6new_hr_fix_stim_nt1.1$Bio_Mean_HR_dif), na.rm = TRUE)))), "outlier", "not outlier")


db_full6new_hr_fix_stim_nt1.1%>%
  ggplot(aes(Bio_Mean_HR_dif))+
  geom_histogram()+
  facet_grid(~Bio_Mean_HR_dif_outl)

```


```{r}

db_full6new_hr_fix_stim_nt1.1<- db_full6new_hr_fix_stim_nt1.1%>%
  ungroup()%>%
  mutate(arousal_c = scale(arousal, center = TRUE, scale = TRUE)[,1],
         valence_c = scale(valence, center = TRUE, scale = TRUE)[,1])

db_full6new_hr_fix_stim_nt1.1 %>%
    # subset(Bio_Mean_HR_dif_outl == "not outlier")%>%
  # subset(ssid_num<500)%>%
  group_by(ssid)%>%
  mutate(Bio_Mean_HR_dif_ssid = mean(Bio_Mean_HR_dif, na.rm = TRUE))%>%
  group_by(ssid)%>%
  # mutate(Bio_Mean_HR_dif_stim = mean(Bio_Mean_HR_dif, na.rm = TRUE))%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(TAS, Bio_Mean_HR_dif))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()


```
  
```{r}

db_full6new_hr_fix_stim_nt1.1 %>%
    subset(Bio_Mean_HR_dif_outl == "not outlier")%>%
  # subset(ssid_num<500)%>%
  # group_by(ssid)%>%
  # mutate(Bio_Mean_HR_dif = abs(Bio_Mean_HR_dif))%>%
  group_by(ssid, stimIAPS)%>%
  # mutate(Bio_Mean_HR_dif_stim = abs(Bio_Mean_HR_dif))%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(TASc, Bio_Mean_HR_dif))+
  
  # geom_point()
  
  geom_smooth(aes(group = stimIAPS, y =Bio_Mean_HR_dif), method=lm, se=FALSE, colour = "gray40", alpha = .01,linetype="dashed", size = .2 )+
  geom_smooth( method=lm, se=FALSE, linetype="dashed",
             color="darkred", size = 2)+
  stat_summary(geom = 'pointrange', pch = 1)+
    # ggpubr::stat_cor()+
  
  
  
  # geom_point()+
  # stat_summary(aes(group =ssid, y = Bio_Mean_HR_dif),method = "line",alpha = .1)+
  # ggpubr::stat_cor()+
  p$graphstyle+
  xlab("Alexithymia (Z)")+
  ylab("HR difference")+
p$graphstyle


```


db_full6new_hr_fix_stim_nt1$TASc<- scale(db_full6new_hr_fix_stim_nt1$TAS, center = TRUE, scale = TRUE)


# model

table(is.na(db_full6new_hr_fix_stim_nt1.1$Bio_Mean_HR_dif))
Bio_Mean_HR_dif_outl

hr_bio <- lmer(Bio_Mean_HR_dif ~ TASc * arousal_c + 
                 (1|ssid) + 
                 (1| stimIAPS),
     REML = FALSE,
     data = subset(db_full6new_hr_fix_stim_nt1.1, 
                   Bio_Mean_HR_dif_outl == "not outlier"))


interactions::interact_plot(hr_bio, pred = arousal_c, modx = TASc)

summary(hr_bio)



# create more variables ground and self
db_full6new_hr_fix_stim_nt1.1<- db_full6new_hr_fix_stim_nt1.1%>%
  ungroup()%>%
  mutate(mediansplit_ground_valence = if_else(ValenceMean >=
                                                  median(ValenceMean,
                                                         na.rm = TRUE), "More positive", "More negative"))%>%
  mutate(mediansplit_ground_arousal = if_else(ArousalMean >=
                                                  median(ArousalMean,
                                                         na.rm = TRUE), "High", "Low"))%>%
    mutate(mediansplit_sample_valence2 = if_else(valence >=
                                                  median(valence,
                                                         na.rm = TRUE), "More positive", "More negative"))%>%
  mutate(mediansplit_sample_arousal2 = if_else(arousal >=
                                                  median(arousal,
                                                         na.rm = TRUE), "High", "Low"))


db_full6new_hr_fix_stim_nt1.1%>%
  subset(Bio_Mean_HR_dif_outl == "not outlier")%>%
  subset(!is.na(mediansplit_ground_valence))%>%
  group_by(ssid,mediansplit_ground_arousal, mediansplit_ground_valence,)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(mediansplit_ground_arousal, Bio_Mean_HR_dif))+
  geom_jitter(alpha = .2, width = .2)+
   geom_bar(stat="summary", fun.y = "mean", alpha = .2)+
  stat_summary(geom = 'pointrange')+
  # stat_smooth(aes(group = ssid), se = F, method = 'lm', alpha = .2)+
    facet_grid(~mediansplit_ground_valence)





```{r}
db_full6new_hr_fix_stim_nt1.1%>%
  subset(!is.na(mediansplit_ground_valence))%>%
  subset(Bio_Mean_HR_dif_outl== "not outlier")%>%
  group_by(ssid, mediansplit_ground_arousal,mediansplit_ground_valence)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(mediansplit_ground_arousal, Bio_Mean_HR_dif, fill = mediansplit_ground_valence))+
  geom_jitter(alpha = .2, width = .2)+
   geom_bar(stat="summary", fun.y = "mean", alpha = .2)+
  stat_summary(geom = 'pointrange')+
  stat_summary(aes(group = ssid), geom = 'line', alpha = .2)+
  
 
  facet_grid(~mediansplit_ground_valence)+
     ggpubr::stat_compare_means()+
  # p$graphstyle+
  scale_fill_brewer(palette = "Dark2")

```



Models

```{r}
table(is.na(db_full6new_hr_fix_stim_nt1.1$Bio_Mean_HR_dif))
test3<- subset(db_full6new_hr_fix_stim_nt1.1, is.na(Bio_Mean_HR_dif))
test4<- subset(db_full6new_hr_fix_stim_nt1.1, !is.na(Bio_Mean_HR_dif))
unique(test4$ssid)

db_full6new_hr_fix_stim_nt1.1$ssid<- as.factor(as.character(db_full6new_hr_fix_stim_nt1.1$ssid))

db_full6new_hr_fix_stim_nt1.1<- db_full6new_hr_fix_stim_nt1.1%>%
  ungroup()%>%
  mutate(arousal_c = scale(arousal, center = TRUE, scale = TRUE)[,1],
         valence_c = scale(valence, center = TRUE, scale = TRUE)[,1])%>%
  mutate(Bio_Mean_HR_dif_c= scale(Bio_Mean_HR_dif, center = TRUE, scale = TRUE)[,1])

unique(db_full6new_hr_fix_stim_nt1$Group)
# test - analyse just positive
summary(hr_dif_models$arousal_val)

hr_dif_models$arousal_val <- lmer(Bio_Mean_HR_dif ~   valence_c+
                                        + (1 | ssid) + 
                                    (1|stimIAPS),
                                        # (1|mediansplit_sample_arousal2),
     REML = FALSE,
     data = subset(db_full6new_hr_fix_stim_nt1.11, 
                   # mediansplit_ground_valence == "More negative" &
                     Bio_Mean_HR_dif_outl == "not outlier"))

summary(hr_dif_models$arousal_val)


summary(hr_dif_models$arousal_AR)


View(db_full6new_hr_fix_stim_nt1.1)

hr_outlier<- subset(db_full6new_hr_fix_stim_nt1.1, 
                   # mediansplit_ground_valence == "More negative" &
                     Bio_Mean_HR_dif_outl != "not outlier")


hr_dif_models$arousal_AR <- lmer(Bio_Mean_HR_dif ~   arousal_c+
                                        + (1 | ssid) + 
                                    (1|stimIAPS),
                                        # (1|mediansplit_sample_arousal2),
     REML = FALSE,
     data = subset(db_full6new_hr_fix_stim_nt1.11, 
                   # mediansplit_ground_valence == "More negative" &
                     Bio_Mean_HR_dif_outl == "not outlier"))


summary(hr_dif_models$arousal_AR)


unique(db_full6new_hr_fix_stim_nt1$ssid)

summary(hr_dif_models$valfrom_hr)

unique(db_full6new_hr_fix_stim_nt1.1$ssid)

db_full6new_hr_fix_stim_nt1.11<- subset(db_full6new_hr_fix_stim_nt1.1, !is.na(stimDescription))

hr_dif_models$valfrom_hr <- lmer(arousal_c ~   Bio_Mean_HR_dif_c* valence_c+
                                         (1 | ssid) + (1|stimIAPS),
                                        # (1|mediansplit_sample_arousal2),
     REML = FALSE,
     data = subset(db_full6new_hr_fix_stim_nt1.11, 
                   # mediansplit_ground_valence == "More positive" &
                   Bio_Mean_HR_dif_outl == "not outlier"))
# arousal_c
summary(hr_dif_models$valfrom_hr)


hr_dif_models$valfrom_hr_ar <- lmer(valence_c ~   Bio_Mean_HR_dif_c * arousal_c+
                                        + (1 | ssid) + (1|stimIAPS),
                                        # (1|mediansplit_sample_arousal2),
     REML = FALSE,
     data = subset(db_full6new_hr_fix_stim_nt1.11, 
                   # mediansplit_ground_valence == "More positive" &
                   Bio_Mean_HR_dif_outl == "not outlier"))
# arousal_c
summary(hr_dif_models$valfrom_hr_ar)

# arousal * valence


db_full6new_hr_fix_stim_nt1.1$arousal_abs<- abs(db_full6new_hr_fix_stim_nt1.1$arousal)
db_full6new_hr_fix_stim_nt1.1$arousal_abs_z<- scale(db_full6new_hr_fix_stim_nt1.1$arousal_abs, center = TRUE,scale = TRUE)


table(is.na(db_full6new_hr_fix_stim_nt1.1$stimDescription))
hr_dif_models$hr_dif_ar_vl <- lmer(Bio_Mean_HR_dif~arousal_c   * valence_c+
                                        + (1 | ssid)+
                                     (1|stimIAPS),
                                        # (1|mediansplit_sample_arousal2),
     REML = FALSE,
     data = subset(db_full6new_hr_fix_stim_nt1.11, 
                   # mediansplit_ground_valence == "More positive" &
                   Bio_Mean_HR_dif_outl == "not outlier" & !is.na(Bio_Mean_HR_dif)))
# arousal_c
summary(hr_dif_models$hr_dif_ar_vl)

# abs
hr_dif_models$hr_dif_arabs_vl <- lmer(Bio_Mean_HR_dif~arousal_abs_z   * valence_c+
                                        + (1 | ssid)+
                                     (1|stimIAPS),
                                        # (1|mediansplit_sample_arousal2),
     REML = FALSE,
     data = subset(db_full6new_hr_fix_stim_nt1.11, 
                   # mediansplit_ground_valence == "More positive" &
                   Bio_Mean_HR_dif_outl == "not outlier" & !is.na(Bio_Mean_HR_dif)))
# arousal_c
summary(hr_dif_models$hr_dif_arabs_vl)






db_full6new_hr_fix_stim_nt1.1%>%
  subset(Bio_Mean_HR_dif_outl == "not outlier" & !is.na(Bio_Mean_HR_dif))%>%
  group_by(ssid)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(valence_c, Bio_Mean_HR_dif))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  xlim(-.4,.6)+
  ggpubr::stat_cor()


db_full6new_hr_fix_stim_nt1.1%>%
  subset(Bio_Mean_HR_dif_outl == "not outlier" & !is.na(Bio_Mean_HR_dif))%>%
  group_by(ssid)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(valence_c, Bio_Mean_HR_dif))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  xlim(-.4,.6)
  ggpubr::stat_cor()
  
  
  
  db_full6new_hr_fix_stim_nt1.11%>%
    subset(Bio_Mean_HR_dif_outl!= "outlier")%>%
    group_by(stimIAPS)%>%
    mutate(mean_hr_dif = mean(Bio_Mean_HR_dif, na.rm = TRUE))%>%
    ggplot(aes(valence_c, mean_hr_dif))+
    # geom_point()+
    stat_summary(aes(y = Bio_Mean_HR_dif),geom = 'pointrange')+
    geom_smooth(method = 'lm', se = F)+
    p$graphstyle
  
  
    db_full6new_hr_fix_stim_nt1.11%>%
    subset(Bio_Mean_HR_dif_outl!= "outlier")%>%
    group_by(stimIAPS)%>%
    mutate(mean_hr_dif = mean(Bio_Mean_HR_dif, na.rm = TRUE))%>%
    ggplot(aes(arousal_abs_z, mean_hr_dif))+
    # geom_point()+
    stat_summary(aes(y = Bio_Mean_HR_dif),geom = 'pointrange')+
    geom_smooth(method = 'lm', se = F)

```



correlaation between the multiple signals

```{r}
table(is.na(db_full6new_hr_fix_stim_nt1.1$BIO_C))
db_full6new_hr_fix_stim_nt1.1$pup_basCor
db_full6new_hr_fix_stim_nt1.1$TTP.nSCR
db_full6new_hr_fix_stim_nt1.1$CDA.nSCR
db_full6new_hr_fix_stim_nt1.1$Bio_Mean_HR_dif


# 
library(tidyverse)
library(ggplot2)
db_full6new_hr_fix_stim_nt1.1<- db_full6new_hr_fix_stim_nt1.1 %>%
  group_by(ssid)%>%
  mutate(BIO_CDA.PhasicMax_z = scale(BIO_CDA.PhasicMax, center = TRUE, scale = TRUE)[,1])%>%
  mutate(BIO_CDA.SCR_z = scale(BIO_CDA.SCR, center = TRUE, scale = TRUE)[,1])%>%
  mutate(BIO_CDA.ISCR_z = scale(BIO_CDA.ISCR, center = TRUE, scale = TRUE)[,1])%>%
  mutate(BIO_TTP.AmpSum_z = scale(BIO_TTP.AmpSum, center = TRUE, scale = TRUE)[,1])%>%
  mutate(BIO_CDA.AmpSum_z = scale(BIO_CDA.AmpSum, center = TRUE, scale = TRUE)[,1])%>%
  mutate(Bio_Mean_HR_dif_z = scale(Bio_Mean_HR_dif, center = TRUE, scale = TRUE)[,1])

unique(db_full6new_hr_fix_stim_nt1.1$ssid)
db_full6new_hr_fix_stim_nt1.1
car::scatter3d(x = db_full6new_hr_fix_stim_nt1.1$pup_basCor, 
          y = db_full6new_hr_fix_stim_nt1.1$BIO_CDA.PhasicMax_z, 
          z = db_full6new_hr_fix_stim_nt1.1$Bio_Mean_HR_dif, 
          fit = "smooth",
          
          surface = TRUE,
          point.col = "blue")
          # point
db_full6new_hr_fix_stim_nt1.1%>%
  group_by(ssid)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(BIO_CDA.PhasicMax_z, pup_basCor))+
  geom_point()+
  geom_smooth(method = lm, se = F)+
  ggpubr::stat_cor()


db_full6new_hr_fix_stim_nt1.1%>%
  group_by(ssid)%>%
  mutate(cor_pup_scr = cor(BIO_CDA.PhasicMax_z, pup_basCor, use = "complete"))%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(cor_pup_scr))+
  geom_histogram()


db_full6new_hr_fix_stim_nt1.1 %>%
  group_by(ssid)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(BIO_CDA.SCR_z, Bio_Mean_HR_dif_z))+
  geom_point()+
  geom_smooth(method = lm, se = F)+
  ggpubr::stat_cor()


db_full6new_hr_fix_stim_nt1.1 %>%
  group_by(ssid)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(BIO_CDA.SCR_z, Bio_Mean_HR))+
  geom_point()+
  geom_smooth(method = lm, se = F)+
  ggpubr::stat_cor()


db_full6new_hr_fix_stim_nt1.1 %>%
  group_by(ssid)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(pup_basCor, Bio_Mean_HR_dif))+
  geom_point()+
  # xlim()
  geom_smooth(method = lm, se = F)+
  # geom_smooth(aes(group = ssid),method = lm, se = F)
  ggpubr::stat_cor()



inter_bio<- lmer(pup_basCor~Bio_Mean_HR_dif +BIO_CDA.PhasicMax_z + (1|ssid)+ (1|stimIAPS), 
                 REML = FALSE,
                 data = db_full6new_hr_fix_stim_nt1.1)

summary(inter_bio)


inter_bio1<- lmer(Bio_Mean_HR_dif~ pup_basCor +BIO_CDA.PhasicMax_z + (1|ssid)+ (1|stimIAPS), 
                 REML = FALSE,
                 data = subset(db_full6new_hr_fix_stim_nt1.1, Bio_Mean_HR_dif_outl!= "outlier"))

summary(inter_bio1)
# MuMin::


table(is.na(db_full6new_hr_fix_stim_nt1.1$BIO_CDA.nSCR))
inter_bio2<- lmer(log1p(BIO_CDA.PhasicMax+.1)~ Bio_Mean_HR_dif + pup_basCor + (1|ssid)+ 
                    (1|stimIAPS), 
                 REML = FALSE,
                 data = subset(db_full6new_hr_fix_stim_nt1.1$BIO_CDA.nSCR, Bio_Mean_HR_dif_outl!= "outlier"))

db_full6new_hr_fix_stim_nt1.1$log_BIO_CDA.PhasicMax<- log1p(db_full6new_hr_fix_stim_nt1.1$BIO_CDA.PhasicMax+.1)
summary(inter_bio2)

sjPlot::tab_model(inter_bio2)

table(is.na(db_full6new_hr_fix_stim_nt1.1$BIO_CDA.PhasicMax))
table(is.na(db_full6new_hr_fix_stim_nt1.1$Bio_Mean_HR_dif))
table(is.na(db_full6new_hr_fix_stim_nt1.1$pup_basCor))

test<- subset(db_full6new_hr_fix_stim_nt1.1, is.na(Bio_Mean_HR_dif))
test<- subset(db_full6new_hr_fix_stim_nt1.1, is.na(pup_basCor))

library(ggplot2)
library(reshape2)
library(data.table)
library(tidyr)
library(tidyverse)
?gather

unique(db_full6new_hr_fix_stim_nt1.1$ssid)

db_full6new_hr_fix_stim_nt1.1 %>%
  mutate(log_BIO_CDA.PhasicMax = log1p(BIO_CDA.PhasicMax+.1))%>%
  subset(ssid!= "347")%>%
  group_by(ssid)%>%
  mutate(Bio_Mean_HR_dif = scale(Bio_Mean_HR_dif, center = TRUE, scale = TRUE)[,1],
         pup_basCor = scale(pup_basCor, center = TRUE, scale = TRUE)[,1],
         log_BIO_CDA.PhasicMax = scale(log_BIO_CDA.PhasicMax, center = TRUE, scale = TRUE)[,1])%>%
  mutate(cor_hr_pup = cor(Bio_Mean_HR_dif, pup_basCor, use = "complete"))%>%
  mutate(cor_hr_scr = cor(Bio_Mean_HR_dif, log_BIO_CDA.PhasicMax, use = "complete"))%>%
  mutate(cor_pup_scr = cor(pup_basCor, log_BIO_CDA.PhasicMax, use = "complete"))%>%
  select(c(ssid, cor_hr_pup, cor_hr_scr, cor_pup_scr))%>%
  gather(key, value, -ssid)%>%
  group_by(ssid, key, value)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(key, value))+
  geom_jitter(width = .1, alpha = .1)+
  geom_line(aes(group = ssid), se = F)+
  stat_summary(geom = 'pointrange')+
  geom_hline(yintercept = 0, size = 1.5, linetype = "dashed")+
  p$graphstyle


db_full6new_hr_fix_stim_nt1.1 %>%
  mutate(log_BIO_CDA.PhasicMax = log1p(BIO_CDA.PhasicMax+.1))%>%
  subset(!is.na(stimIAPS))%>%
  group_by(stimIAPS)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ungroup()%>%
  # group_by(stimIAPS)%>%
  mutate(cor_hr_pup = cor(Bio_Mean_HR_dif, pup_basCor, use = "complete"))%>%
  mutate(cor_hr_scr = cor(Bio_Mean_HR_dif, log_BIO_CDA.PhasicMax, use = "complete"))%>%
  mutate(cor_pup_scr = cor(pup_basCor, log_BIO_CDA.PhasicMax, use = "complete"))%>%
  select(c(stimIAPS, cor_hr_pup, cor_hr_scr, cor_pup_scr))%>%
  gather(key, value, -stimIAPS)%>%
  group_by(stimIAPS, key, value)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(key, value))+
  geom_hline(yintercept = 0, size = 1.5, linetype = "dashed")+
  geom_jitter(width = .1, alpha = .1)+
  geom_line(aes(group = stimIAPS), se = F)+
  stat_summary(geom = 'pointrange')+
  # ggpubr::stat_compare_means(paired = FALSE)+
  p$graphstyle



db_full6new_hr_fix_stim_nt1.1 %>%
  group_by(ssid)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(Bio_Mean_HR_dif, pup_basCor))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()

db_full6new_hr_fix_stim_nt1.1 %>%
  group_by(ssid)%>%
  subset(Bio_Mean_HR_dif_outl!= "outlier")%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(Bio_Mean_HR_dif, pup_basCor))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()


db_full6new_hr_fix_stim_nt1.1 %>%
  group_by(stimIAPS)%>%
  subset(Bio_Mean_HR_dif_outl!= "outlier")%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  ggplot(aes(Bio_Mean_HR_dif, pup_basCor))+
  geom_point()+
  geom_smooth(method = 'lm', se = F)+
  ggpubr::stat_cor()

```



# cluster based on bio, pupil angsr_selfrep_matrixthen take these clusters and compare arousal valence

Let's crate some sort of data driven  parceling of the data
option one, use a clustering algorithm that receives 3 inputs: pupil, heart rate and SCR and spits clusters,

and then we can compare these clusters on ground truth arousal and valence
- decisions to make: do we average the responses per participant and cluster at a trial level - this ignores individual variability
- what do we do with the nested nature of teh data, one participant has multiple trials, if we don't accout for this, the cluster will treat data from different participants the same way.

If we create cluster on a individual level- then the issue is different participants will end up with different clusters and clusters for one person are not translatable.


The PCA type we did in newyork - barycentric?


Let's start with an aggregated case, ignore subjects


```{r}
library(tidyverse)
db_full6new_hr_fix_stim_nt1.1

clustering<- db_full6new_hr_fix_stim_nt1.1%>%
  subset(Bio_Mean_HR_dif_outl == "not outlier")%>%
  select(
                    c(Bio_Mean_HR_dif, pup_basCor, BIO_CDA.PhasicMax, BIO_CDA.ISCR, BIO_TTP.AmpSum,
                      BIO_CDA.SCR, arousal, valence, ArousalMean, ValenceMean, stimIAPS, tNo, TAS, AQ, Age,
                      gender, ssid, stimDescription, fix_count, mean_fix_dur))

View(clustering)


clustering$stimIAPS2<- substr(clustering$stimIAPS, 1,4)
unique(clustering$stimIAPS)

clustering<- subset(clustering, !is.na(stimIAPS2))

unique(clustering$stimIAPS2)

clusterin
clustering[clustering == "NaN"]<- NA

# create logarithims for SCR

clustering<- clustering%>%
  mutate(log_BIO_CDA.PhasicMax = log1p(BIO_CDA.PhasicMax+.1))%>%
   mutate(log_BIO_CDA.ISCR = log1p(BIO_CDA.ISCR+.1))%>%
  mutate(log_BIO_TTP.AmpSum = log1p(BIO_TTP.AmpSum+.1))%>%
  mutate(log_BIO_CDA.SCR = log1p(BIO_CDA.SCR+.1))%>%
  group_by(ssid)%>%
  # mutate(log_Bio_Mean_HR_dif_z = scale(log_Bio_Mean_HR_dif, center  = TRUE, scale= TRUE))%>%
  # mutate(pup_basCor_z = scale(pup_basCor, center  = TRUE, scale= TRUE))%>%
  mutate(log_Bio_CDA.PhasicMax_z = scale(log_BIO_CDA.PhasicMax, center  = TRUE, scale= TRUE))%>%
  mutate(log_Bio_CDA.ISCR_z = scale(log_BIO_CDA.ISCR, center  = TRUE, scale= TRUE))%>%
  mutate(log_Bio_TTP.AmpSum_z = scale(log_BIO_TTP.AmpSum, center  = TRUE, scale= TRUE))%>%
  mutate(log_Bio_CDA.SCR_z = scale(log_BIO_CDA.SCR, center  = TRUE, scale= TRUE))


# aggregate for clustering first

clustering$AlexGroup<- if_else(clustering$TAS> median(clustering$TAS, na.rm = TRUE), "High", "Low")

clustering_agg <- clustering%>%
  group_by(stimIAPS2, stimDescription)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)

clustering_agg2 <- clustering%>%
  group_by(stimIAPS2, stimDescription,AlexGroup)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)

clustering_agg<- clustering_agg%>%
  ungroup()%>%
  mutate(Bio_Mean_HR_dif_z = scale(Bio_Mean_HR_dif, center  = TRUE, scale= TRUE))%>%
  mutate(pup_basCor_z = scale(pup_basCor, center  = TRUE, scale= TRUE))
  # mutate(BIO_CDA.PhasicMax_z = scale(BIO_CDA.PhasicMax, center  = TRUE, scale= TRUE))%>%
  #  mutate(BIO_CDA.ISCR_z = scale(BIO_CDA.ISCR, center  = TRUE, scale= TRUE))%>%
  # mutate(BIO_TTP.AmpSum_z = scale(BIO_TTP.AmpSum, center  = TRUE, scale= TRUE))%>%
  # mutate(BIO_CDA.SCR_z = scale(BIO_CDA.SCR, center  = TRUE, scale= TRUE))

clustering_agg2<- clustering_agg2%>%
  ungroup()%>%
  mutate(Bio_Mean_HR_dif_z = scale(Bio_Mean_HR_dif, center  = TRUE, scale= TRUE))%>%
  mutate(pup_basCor_z = scale(pup_basCor, center  = TRUE, scale= TRUE))

View(clustering_agg)

write_csv(clustering_agg, "clustering_agg.csv")

# kmeans clustering

```

```{r}
library(readr)
View(clustering_agg_JASP)
clustering_agg_JASP <- read_csv("clustering_agg_JASP.csv")
View(clustering_agg_JASP)

clustering_agg_JASP$valence_median_split<- if_else(clustering_agg_JASP$valence > median(clustering_agg_JASP$valence,na.rm = TRUE), "positive", "negative")

clustering_agg_JASP$ValenceMean_median_split <- if_else(clustering_agg_JASP$ValenceMean > median(clustering_agg_JASP$ValenceMean,na.rm = TRUE), "positive", "negative")

clustering_agg_JASP%>%
  mutate(abs_ar  = abs(arousal))%>%
  # ggplot(aes(valence_median_split, arousal))+
  ggpubr::ggboxplot(x = "valence_median_split", y = "abs_ar")+
  geom_point()


clustering_agg_JASP%>%
  mutate(abs_ar = abs(clustering_agg_JASP))
  # ggplot(aes(valence_median_split, arousal))+
  ggpubr::ggboxplot(x = "ValenceMean_median_split", y = "ArousalMean")+
  geom_point()+
  stat_summary(geom = 'pointrange')

write_csv(clustering_agg_JASP, "clustering_agg_JASP_newtomatch.csv")

library(readxl)
macthed_test <- read_excel("macthed_test.xlsx")
View(macthed_test)

macthed_test%>%
  # ggplot(aes(valence_median_split, arousal))+
  ggpubr::ggboxplot(x = "ValenceMean_median_split", y = "ArousalMean")+
  # geom_point()+
  stat_summary(geom = 'pointrange')
```


stomdescr<- select(clustering_agg, c(stimIAPS2, stimDescription))
clustering_agg_JASP$stimIAPS2<- as.character(clustering_agg_JASP$stimIAPS2)

left_join(clustering_agg_JASP, stomdescr)%>%
  ggplot(aes( arousal, valence, color = as.factor(clusters)))+
  geom_text(aes(label = stimDescription))+
  facet_grid(~ as.factor(clusters))



left_join(clustering_agg_JASP, stomdescr)%>%
  ggplot(aes( as.factor(clusters), valence))+
  geom_jitter(width = .2)+
  stat_summary(geom  = 'pointrange')


left_join(clustering_agg_JASP, stomdescr)%>%
  ggplot(aes( as.factor(clusters), abs(arousal)))+
  geom_jitter(width = .2)+
  stat_summary(geom  = 'pointrange')

  geom_text(aes(label = stimDescription))+
  facet_grid(~ as.factor(clusters))




Kmeans random initialisation trap
- what happens if we have a bad ramdon initialization fior centroids (center of mass)?
The selection can ditacte the outcome.

Solution? K-means++ (happens in the background)

steps
1 - choose the number of k clusters
2 - select k points and random (centroids) don't need to be in the data
3 - assign each data point the the closest centroid
4 - compute and lace new centroids for each cluster
5 - Reassign each data point to the new closest centroid, if any reassignment take place go back to 4 other wise convergence

Find how the right number of clusters
- look at the within cluster summ of squares (distance between the point and the centroid) like in regression if numerator sum of sqyares is bigger than error, we tend to have significant results. we want the modelwith the smalles within sum of squares (elbow method) - looks like a screeplot



note for clustering methods, because the solution is not known we don't typically have crossvalidation, but can asses stability, etc

regular k means on aggregaed data

```{r}
# K-Means Clustering

# Importing the dataset

clustering_agg<- subset(clustering_agg, !is.na(stimDescription))

clustering_agg$AlexGroup<- if_else(clustering_agg$TAS> median(clustering_agg$TAS, na.rm = TRUE), "High", "Low")
colnames(clustering_agg)
clust_dataset = clustering_agg_noflood[c(25,24,20)]


# Feature Scaling
# training_set = scale(training_set)
# test_set = scale(test_set)

# Using the elbow method to find the optimal number of clusters
set.seed(1)
wcss = vector()
for (i in 1:10) wcss[i] = sum(kmeans(clust_dataset, i)$withinss)
plot(1:10,
     wcss,
     type = 'b',
     main = paste('The Elbow Method'),
     xlab = 'Number of clusters',
     ylab = 'WCSS')

# Fitting K-Means to the dataset
set.seed(25)
kmeans = kmeans(x = clust_dataset, centers = 3)
y_kmeans = kmeans$cluster

# Visualising the clusters
# install.packages("cluster")
library(cluster)

?clusplot

clust_dataset
y_kmeans
clusplot(clust_dataset,
         y_kmeans,
         lines = 2,
         shade = TRUE,
         color = TRUE,
         labels = 1,
         plotchar = FALSE,
         span = TRUE
         # label = 
         # main = paste('Clusters of customers'),
         # xlab = 'Annual Income',
         # ylab = 'Spending Score'
         )

test$Distances
```

a few visualisations
```{r}
clustering_agg_noflood$y_kmeans<- y_kmeans



?car::scatter3d
View(clustering_agg)
clustering_agg_noflood$y_kmeans<- as.factor(as.character(clustering_agg_noflood$y_kmeans))

clustering_agg2$y_kmeans<- as.factor(as.character(clustering_agg2$y_kmeans))

car::scatter3d(clustering_agg$log_Bio_CDA.PhasicMax_z, 
          clustering_agg$Bio_Mean_HR_dif_z, 
          clustering_agg$pup_basCor_z,
          fit = "smooth",
          point = TRUE,
          # ellipsoid = TRUE,
          surface = FALSE,
          groups = clustering_agg$y_kmeans,
          point.col = clustering_agg$y_kmeans
          )


clustering_agg2$AlexGroup<-as.factor(clustering_agg2$AlexGroup)
clustering_agg2<- subset(clustering_agg2, !is.na(stimDescription))
car::scatter3d(clustering_agg2$log_Bio_CDA.PhasicMax_z, 
          clustering_agg2$Bio_Mean_HR_dif_z, 
          clustering_agg2$pup_basCor_z,
          fit = "smooth",
          # point = FALSE,
          ellipsoid = TRUE,
          surface = FALSE,
          groups = clustering_agg2$AlexGroup
          # point.col = clustering_agg2$y_kmeans
          )


# install.packages("scatterplot3d") # Install
library("scatterplot3d") # load


scatterplot3d(clustering_agg[,c(20,24,25)],pch = 16, color = clustering_agg$y_kmeans, type="h")
text(clustering_agg$stimDescription, labels = clustering_agg$stimDescription,
     cex= 0.7, col = "steelblue")


require(ggplot2)
# data("iris")

clust_dataset

clustering_agg%>%
  subset(y_kmeans == 3)%>%
  select(c(stimDescription))

clustering_agg_JASPtest%>%
   subset(clusters == 3)%>%
  select(c(stimDescription))

clustering_agg_bonkers <- subset(clustering_agg, stimIAPS2 != "9926")

pca_res <- prcomp(clustering_agg[,c(25,24,20)], center = TRUE, scale. = TRUE)
pca_res <- prcomp(clustering_agg_JASPtest[,c(24,23,19)], center = TRUE, scale. = TRUE)
plot_data <- cbind(as.data.frame(pca_res$x[, 1:2]), labels = clustering_agg$y_kmeans)

# plot_data$
ggplot(plot_data, aes(x = PC1, y = PC2, colour = labels, fill = labels)) +
  geom_point(size = 2, alpha = .4)+
  geom_text(aes(label= clustering_agg$stimDescription))+
  stat_ellipse(show.legend = TRUE)+
  ylab("Componet 2")+
  xlab("Component 1")+
  # scale_color_manual(values = c("red", "green", "blue"))+
  p$graphstyle+
  theme()

?scale_color_manual
scale_color_brewer(breaks=c("1","5","10","50","100"), palette = "Set1")
```


clustering_agg$cluster_interpreted<- ifelse(clustering_agg$y_kmeans == 1, "mixed",
                                            ifelse(clustering_agg$y_kmeans == 2, "highlyarousing_aitated", "calmish"))
summary(pca_res)

# tsne plot
install.packages("tsne")
library(tsne)

?tsne

# install.packages("Rtsne")
require(Rtsne)
# install.packages("M3C")
# library(M3C)
tsne(clustering_agg[,c(20,24,25)])


# cluster vs ground arousal means
library(tidyverse)
clustering_agg%>%
  ggplot(aes(as.factor(y_kmeans), ArousalMean))+
  # geom_point()+
  stat_summary(geom = 'pointrange')+
  ggpubr::stat_compare_means()

clustering_agg %>%
  ggplot(aes(cluster_interpreted, ArousalMean))+
  # geom_point()+
  stat_summary(geom = 'pointrange')+
    ggpubr::stat_compare_means()


# cluster vs valence ground

# Visualize: Specify the comparisons you want
my_comparisons <- list( c("1", "2"), c("1", "3"), c("2", "3") )
my_comparisons <- list( c("mixed", "highlyarousing_aitated"), c("mixed", "calmish"), c("highlyarousing_aitated", "calmish") )
clustering_agg$cluster_interpreted
library(ggpubr)

ggboxplot(clustering_agg, x = "cluster_interpreted", y = "ArousalMean",
          color = "cluster_interpreted", palette = "jco")+
  geom_jitter(width = .1, alpha = .2)+
  stat_compare_means(comparisons = my_comparisons)+ # Add pairwise comparisons p-value
  stat_compare_means(label.y = 9)     # Add global p-value



clustering_agg %>%
  ggplot(aes(as.factor(y_kmeans), ValenceMean))+
  geom_point()+
  stat_summary(geom = 'pointrange')

clustering_agg%>%
  ggplot(aes(cluster_interpreted, ValenceMean))+
  # geom_point()+
  stat_summary(geom = 'pointrange')+
    ggpubr::stat_compare_means()

ggboxplot(clustering_agg, x = "cluster_interpreted", y = "ValenceMean",
          color = "cluster_interpreted", palette = "jco")+
  geom_jitter(width = .1, alpha = .2)+
  stat_compare_means(comparisons = my_comparisons)+ # Add pairwise comparisons p-value
  stat_compare_means(label.y = 9)  



tmp.df4_full_stim_downs_jun2021_60bins_no_na %>%
  group_by(ssid, cluster_interpreted)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  mutate(arousal2 = abs(arousal))%>%
  subset(arousal> -9)%>%
  ggboxplot(x = "cluster_interpreted", y = "valence",
          color = "cluster_interpreted", palette = "jco")+
  geom_jitter(width = .1, alpha = .2)+
    stat_summary(aes(group =ssid), geom =  'line', alpha = .2, size = .1)+
  stat_compare_means(comparisons = my_comparisons)+ # Add pairwise comparisons p-value
  stat_compare_means(label.y = 9) 

options(scipen = 999)

```{r}
tmp.df4_full_stim_downs_jun2021_60bins_no_na%>%
  group_by(ssid, cluster_interpreted)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)%>%
  mutate(arousal2 = abs(arousal))%>%
  subset(arousal> -9)%>%
  ggboxplot(x = "cluster_interpreted", y = "arousal",
          color = "cluster_interpreted", palette = "jco")+
  geom_jitter(width = .1, alpha = .2)+
    stat_summary(aes(group =ssid), geom =  'line', alpha = .2, size = .1)+
  stat_compare_means(comparisons = my_comparisons)+ # Add pairwise comparisons p-value
  stat_compare_means(label.y = 9)
  


```


```{r}


# based ins ample
clustering_agg %>%
  ggplot(aes(as.factor(y_kmeans), valence))+
  geom_point()+
  stat_summary(geom = 'pointrange')

clustering_agg %>%
  ggplot(aes(cluster_interpreted, valence))+
  # geom_point()+
  stat_summary(geom = 'pointrange')+
    ggpubr::stat_compare_means()


clustering_agg%>%
  ggplot(aes(as.factor(y_kmeans), arousal))+
  geom_point()+
  stat_summary(geom = 'pointrange')

clustering_agg%>%
  ggplot(aes(cluster_interpreted, arousal))+
  # geom_point()+
  stat_summary(geom = 'pointrange')+
  ggpubr::stat_compare_means()

cluster_stim<- select(clustering_agg, c(stimIAPS2,y_kmeans, cluster_interpreted, stimDescription))


# plot(test)
```


use the clusters ti fit mixed models


```{r}
View(clustering)

table(is.na(clustering$stimDescription))
table(is.na(clustering2$stimDescription))

clustering2

clustering3<- left_join(clustering2, cluster_stim)
nrow(clustering2)
nrow(clustering3)

cluster_lmers<- list()
clustering_new$stimIAPS2<- as.factor(as.character(clustering_new$stimIAPS2))

clustering_new$ssid<- as.factor(as.character(clustering_new$ssid))
View(clustering_new)

library(lmerTest)

clustering3$arousal
clustering_new$Cluster<- as.factor(clustering_new$Cluster)
cluster_lmers$arousal <- lmer(arousal ~ Cluster + 
                               (1 | ssid)+
                               (1|stimIAPS),
                             REML = FALSE,
                             data = clustering_new)

summary(cluster_lmers$arousal)

anova(cluster_lmers$arousal)

emmeans::emmeans(cluster_lmers$arousal, pairwise~Cluster)

# valence
cluster_lmers$valence <- lmer(valence ~ Cluster + 
                               (1 | ssid)+
                               (1|stimIAPS),
                             REML = FALSE,
                             data = clustering_new)

summary(cluster_lmers$valence)
emmeans::emmeans(cluster_lmers$valence, pairwise~Cluster)


clustering_new_agg<- clustering_new%>%
  subset(!is.na(Cluster))%>%
  group_by(ssid, Cluster)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)
clustering_new_agg$Cluster<- factor(clustering_new_agg$Cluster)

clustering_new_agg
clusr_ar<- afex::aov_ez(id = "ssid",
             data = clustering_new_agg,
             dv = "arousal",
             within = "Cluster",
             between = NULL)


clustering_new_agg%>%
  ggplot(aes(Cluster, arousal))+
  geom_jitter(width = .2)+
  geom_boxplot()
emmeans::emmeans(clusr_ar, pairwise~Cluster, adjust = "bonf")


clusr_vl<- afex::aov_ez(id = "ssid",
             data = clustering_new_agg,
             dv = "valence",
             within = "Cluster",
             between = NULL)

emmeans::emmeans(clusr_vl, pairwise~Cluster, adjust = "bonf")

cluster_lmers$pup_clust <- lmer(pup_basCor ~ cluster_interpreted + 
                               (1 | ssid)+
                               (1|stimIAPS2),
                             REML = FALSE,
                             data = clustering3)
                             
cluster_lmers$pup_clust1 <- lmer(pup_basCor ~ y_kmeans + 
                               (1 | ssid)+
                               (1|stimIAPS2),
                             REML = FALSE,
                             data = clustering3)
                             
summary(cluster_lmers$pup_clust1)

emmeans::emmeans(cluster_lmers$pup_clust1, pairwise~y_kmeans, adjust = "bonf")


table(is.na(clustering3$Bio_Mean_HR_dif))
cluster_lmers$hrdif_clust2 <- lmer(Bio_Mean_HR_dif ~ y_kmeans + 
                               (1 | ssid),
                               # <!-- (1|stimIAPS2), -->
                             REML = FALSE,
                             data = clustering3)
                             
                             summary(cluster_lmers$pup_clust1)

emmeans::emmeans(cluster_lmers$hrdif_clust2, pairwise~y_kmeans, adjust = "bonf")
summary(cluster_lmers$hrdif_clust2)

View(clustering3)
cluster_lmers$scr_clust2 <- lmer(log_BIO_CDA.PhasicMax ~ y_kmeans + 
                               (1 | ssid)+
                               (1|stimIAPS),
                             REML = FALSE,
                             data = clustering3)
                             
                             summary(cluster_lmers$scr_clust2)

emmeans::emmeans(cluster_lmers$scr_clust2, pairwise~y_kmeans, adjust = "bonf")
summary(cluster_lmers$hrdif_clust2)


```



Let's do on the unnagregated data


```{r}
colnames(clustering_agg)
colnames(clustering)


View(clustering)
clustering2<- subset(clustering, !is.na(stimDescription))


# K-Means Clustering

View(clustering2)
colnames(clustering2)
clust2_dataset = clustering2[c(24,2,1,7:11,18,19)]


# Feature Scaling
# training_set = scale(training_set)
# test_set = scale(test_set)

# Using the elbow method to find the optimal number of clusters
set.seed(6)
wcss2 = vector()
View(clust2_dataset)
clust2_dataset_nona<- na.omit(clust2_dataset)

for (i in 1:10) wcss2[i] = sum(kmeans(clust2_dataset_nona[,c(1:3)], i)$withinss)
plot(1:10,
     wcss,
     type = 'b',
     main = paste('The Elbow Method'),
     xlab = 'Number of clusters',
     ylab = 'WCSS')

# Fitting K-Means to the dataset
set.seed(29)
kmeans2 = kmeans(x = clust2_dataset_nona[,c(1:3)], centers = 3)
y_kmeans2 = kmeans2$cluster

# Visualising the clusters
# install.packages("cluster")
library(cluster)

?clusplot
clusplot(clust_dataset,
         y_kmeans,
         lines = 0,
         shade = TRUE,
         color = TRUE,
         labels = 2,
         plotchar = FALSE,
         span = TRUE
         # main = paste('Clusters of customers'),
         # xlab = 'Annual Income',
         # ylab = 'Spending Score'
         )

clust2_dataset_nona$y_kmeans2 <- y_kmeans2

clust2_dataset_nona%>%
  ggplot(aes(as.factor(y_kmeans2), ArousalMean))+
  # geom_point()+
  stat_summary(geom = 'pointrange')

clust2_dataset_nona%>%
  ggplot(aes(as.factor(y_kmeans2), ValenceMean))+
  # geom_point()+
  stat_summary(geom = 'pointrange')

clustering_agg%>%
  ggplot(aes(as.factor(y_kmeans), valence))+
  geom_point()+
  stat_summary(geom = 'pointrange')


clustering_agg%>%
  ggplot(aes(as.factor(y_kmeans), arousal))+
  geom_point()+
  stat_summary(geom = 'pointrange')

?car::scatter3d
View(clustering_agg)

clust2_dataset_nona$y_kmeans2<- as.factor(as.character(clust2_dataset_nona$y_kmeans2))
car::scatter3d(clust2_dataset_nona$log_Bio_CDA.PhasicMax_z, 
          clust2_dataset_nona$Bio_Mean_HR_dif, 
          clust2_dataset_nona$pup_basCor,
          fit = "smooth",
          # point = FALSE,
          # ellipsoid = TRUE,
          surface = FALSE,
          # groups = clust2_dataset_nona$y_kmeans2,
          point.col = clust2_dataset_nona$y_kmeans2
          )


# install.packages("scatterplot3d") # Install
library("scatterplot3d") # load


scatterplot3d(clustering_agg[,c(20,24,25)],pch = 16, color = clustering_agg$y_kmeans, type="h")
text(clustering_agg$stimDescription, labels = clustering_agg$stimDescription,
     cex= 0.7, col = "steelblue")


require(ggplot2)
data("iris")

pca_res2 <- prcomp(clust2_dataset_nona[,c(1:3)])
plot_data2 <- cbind(as.data.frame(pca_res2$x[, 1:2]), labels = clust2_dataset_nona$y_kmeans2)

ggplot(plot_data, aes(x = PC1, y = PC2, colour = labels)) +
  # geom_point()
  geom_text(aes(label= clust2_dataset_nona$stimDescription))


summary(pca_res2)
```


PCA and barycentric

```{r}

clustering
clustering_agg
clustering_agg_JASP
clustering_agg2
clustering

clustering_new
# clustering3 has problems

# 1 dcast stim to columns 

colnames(clustering_new)
colnames(clustering)

View(db_full6new_hr_fix_stim_select2_NT_no_outl_5)
db_forBADA1<- data.table::dcast(setDT(db_full6new_hr_fix_stim_select2_NT_no_outl_5), 
                    ssid + TAS+AQ+Group ~ stimIAPS2, value.var = c('pup_basCor',
                'Bio_Mean_HR_dif', 'log1p_BIO_CDA.PhasicMax', 'arousal', 'valence'))


library(data.table)
colnames(clustering_new)
library(tidyverse)


# clustering_new$=
# clustering
View(clustering)
clustering_new_pre_PCA<- select(clustering, c(ssid, TAS, AQ, stimIAPS2,
                                              stimDescription, 
                                                  pup_basCor,Bio_Mean_HR_dif,
                                                  log_BIO_CDA.PhasicMax, arousal,
                                                  valence, fix_count, mean_fix_dur))
View(clustering_new_pre_PCA)

clustering_new_pre_PCA

clustering_new_pre_PCA$stim_descr<- paste0(clustering_new_pre_PCA$stimIAPS2, 
                                           paste0(clustering_new_pre_PCA$stimDescription))

clustering_new_pre_PCA$stim_descr

clustering_new_pre_PCA
db_forPCA<- data.table::dcast(setDT(clustering_new_pre_PCA), 
                    ssid + TAS+AQ ~ stim_descr, value.var = c('pup_basCor',
                'Bio_Mean_HR_dif', 'log_BIO_CDA.PhasicMax', 'arousal', 'valence', 
                'fix_count', 'mean_fix_dur'))

View(db_forPCA)
colnames(db_forPCA)

# 
# start with just physio stuff


all.data<- db_forPCA

# count NAS on the important variables
# pupufirst(

colnames(all.data[,61: (61+56)])
all.data$per_ssid_pupil_loss_perc <- (rowSums(is.na(all.data[,4:60]))/56)*100 # pupil
# rowSums(is.na(all.data[,4:60]))
all.data$per_ssid_hr_loss_perc<-  (rowSums(is.na(all.data[,61: (61+56)]))/56)*100 # heart rate
all.data$per_ssid_scr_loss_perc<- (rowSums(is.na(all.data[,(61+56):(61+56+56)]))/56)*100 # scr

# columns


cols_belowmissingthresh <- which(colSums(is.na(all.data))/nrow(all.data) < .8)
  # all.data%>%
colSums(is.na(all.data))/nrow(all.data)

ncol(all.data)
# select columsn that don't have a a lot of missingness
all.data1<- all.data%>%
  select(cols_belowmissingthresh)

View(all.data1)

# exclude peope with more han 50% missign data

all.data1$per_ssid_pupil_loss_perc

all.data2<- subset(all.data1,
                   per_ssid_pupil_loss_perc< 24)

# now mean wise inputation based on each variable
all.data2

colnames(all.data2)
# pupil row-wise inputation
k <- which(is.na(all.data2[, c(1,4:59)]), arr.ind=TRUE)
k
all.data3<- all.data2
all.data3pup<- all.data2[, c(1,4:59)]

all.data3pup[k] <- rowMeans(all.data3pup[, 2:57], na.rm=TRUE)[k[,1]]

# HR
all.data3_hr<- all.data3[,c(1,60:115)]
k <- which(is.na(all.data3_hr[, 1:57]), arr.ind=TRUE)
k

all.data3_hr[k] <- rowMeans(all.data3_hr[, 2:57], na.rm=TRUE)[k[,1]]

# SCR
colnames(all.data3)
all.data3_scr<- all.data3[,c(1,116:171)]
k_scr <- which(is.na(all.data3_scr[, 1:57]), arr.ind=TRUE)
k_scr

all.data3_scr[k_scr] <- rowMeans(all.data3_scr[, 2:57], na.rm=TRUE)[k_scr[,1]]

# merge()
all.data3_forPCA<- all.data3[,1:3]

all.data3_forPCA<- left_join(all.data3_forPCA, all.data3pup)
all.data3_forPCA<- left_join(all.data3_forPCA, all.data3_hr)
all.data3_forPCA<- left_join(all.data3_forPCA, all.data3_scr)



 # design
# var.design_asd <- as.factor(all.data$Group)

colnames(all.data3_forPCA)

var.data <- all.data3_forPCA[,c(4:171)]

library(TInPosition)
library(prettyGraphs)

# inferential PCA
var.PCA.scr_hr_pup <-InPosition::epPCA.inference.battery(var.data, 
                                       scale = TRUE, 
                                       center = TRUE, 
                                       # DESIGN = var.design_asd, 
                                       # make_design_nominal = TRUE, 
                                       graphs = TRUE, k = 0, 
                                       test.iters = 1000, 
                                       constrained = FALSE, 
                                       critical.value = 2)

# includValenceMean_median_split
colnames(all.data3)

all.data3_val<- all.data3[,c(1,228:283)]

all.data3_val
k_val <- which(is.na(all.data3_val[, c(1:57)]), arr.ind=TRUE)
k_val
all.data3_val[k_val] <- rowMeans(all.data3_val[, 2:57], na.rm=TRUE)[k_val[,1]]

all.data3_forPCA_withval<- left_join(all.data3_forPCA, all.data3_val)

# subjective arousal

all.data3_ar<- all.data3[,c(1,172:227)]

all.data3_ar
k_ar <- which(is.na(all.data3_ar[, c(1:57)]), arr.ind=TRUE)
k_ar
all.data3_ar[k_ar] <- rowMeans(all.data3_ar[, 2:57], na.rm=TRUE)[k_ar[,1]]

all.data3_forPCA_withar<- left_join(all.data3_forPCA, all.data3_ar)


library(InPosition)
var.PCA.scr_hr_pup_val <-InPosition::epPCA.inference.battery(all.data3_forPCA_withval[,4:226], 
                                       scale = TRUE, 
                                       center = TRUE, 
                                       # DESIGN = var.design_asd, 
                                       # make_design_nominal = TRUE, 
                                       graphs = TRUE, k = 0, 
                                       test.iters = 1000, 
                                       constrained = FALSE, 
                                       critical.value = 2)


# with self arousal
var.PCA.scr_hr_pup_ar <-InPosition::epPCA.inference.battery(all.data3_forPCA_withar[,4:227], 
                                       scale = TRUE, 
                                       center = TRUE, 
                                       # DESIGN = var.design_asd, 
                                       # make_design_nominal = TRUE, 
                                       graphs = TRUE, k = 0, 
                                       test.iters = 1000, 
                                       constrained = FALSE, 
                                       critical.value = 2)


View(all.data3_forPCA_withar)

View(clustering_new_pre_PCA)
```

Multiple factor analysys

- consider aggregating  (average per stim)
- PCA on arousal arousal and valence


```{r}

library(factoextra)
library(FactoMineR)

clustering_new_pre_PCA
colnames(clustering_new_pre_PCA)

clustering_new_pre_PCA_2<- clustering_new_pre_PCA[, c(1,5:10,12)]
colnames(clustering_new_pre_PCA_2)

MFA(base, group, type = rep("s",length(group)), ind.sup = NULL, 
    name.group = NULL, num.group.sup = NULL, graph = TRUE)


res.mfa <- MFA(wine, 
               group = c(2, 5, 3, 10, 9, 2), 
               type = c("n", "s", "s", "s", "s", "s"),
               name.group = c("origin","odor","visual",
                              "odor.after.shaking", "taste","overall"),
               num.group.sup = c(1, 6),
               graph = FALSE)

clustering_new_pre_PCA_2

View(clustering_new_pre_PCA_2)

clustering_new_pre_PCA_2$ssid<- as.factor(clustering_new_pre_PCA_2$ssid)
?MFA

clustering_new_pre_PCA_2$stimDescription
res.mfa <- MFA(clustering_new_pre_PCA_2, 
               group = c(2, 1, 1, 1, 2, 1), 
               type = c("n", "s", "s", "s", "s", "s"),
               name.group = c("pp_stim","pupil","HR","SCR", "ar_val","fix"),
               num.group.sup = c(1,2),
               graph = TRUE)

print(res.mfa)


clustering_new_pre_PCA_2print(res.mfa)

```
```{r}
library("factoextra")
eig.val <- get_eigenvalue(res.mfa)
head(eig.val)

install.packages("MExPosition")
# ExPosition::FA

TExPosition::
# InPosition::
# TExPosition::

```

the function fviz_eig() or fviz_screeplot() [factoextra package] can be used to draw the scree plot:
```{r}
fviz_screeplot(res.mfa)

```

The function get_mfa_var() [in factoextra] is used to extract the results for groups of variables. This function returns a list containing the coordinates, the cos2 and the contribution of groups, as well as, the

```{r}

group <- get_mfa_var(res.mfa, "group")
group

```

The different components can be accessed as follow:
```{r}
# Coordinates of groups
head(group$coord)
# Cos2: quality of representation on the factore map
head(group$cos2)
# Contributions to the  dimensions
head(group$contrib)

```

To plot the groups of variables, type this:

```{r}
fviz_mfa_var(res.mfa, "group")

```


red color = active groups of variables
green color = supplementary groups of variables
The plot above illustrates the correlation between groups and dimensions. The coordinates of the four active groups on the first dimension are almost identical. This means that they contribute similarly to the first dimension. Concerning the second dimension, the two groups - odor and odor.after.shake - have the highest coordinates indicating a highest contribution to the second dimension.

To draw a bar plot of groups contribution to the dimensions, use the function fviz_contrib():
```{r}
# Contribution to the first dimension
fviz_contrib(res.mfa, "group", axes = 1)
# Contribution to the second dimension
fviz_contrib(res.mfa, "group", axes = 2)

```
Quantitative variables
The function get_mfa_var() [in factoextra] is used to extract the results for quantitative variables. This function returns a list containing the coordinates, the cos2 and the contribution of variables:
```{r}
quanti.var <- get_mfa_var(res.mfa, "quanti.var")
quanti.var 

```
```{r}
# Coordinates
head(quanti.var$coord)
# Cos2: quality on the factore map
head(quanti.var$cos2)
# Contributions to the dimensions
head(quanti.var$contrib)

```
Correlation between quantitative variables and dimensions. The R code below plots quantitative variables colored by groups. The argument palette is used to change group colors (see ?ggpubr::ggpar for more information about palette). Supplementary quantitative variables are in dashed arrow and violet color. We use repel = TRUE, to avoid text overlapping.

```{r}
fviz_mfa_var(res.mfa, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE)

```

To make the plot more readable, we can use geom = c(“point”, “text”) instead of geom = c(“arrow”, “text”). We’ll change also the legend position from “right” to “bottom”, using the argument legend = “bottom”:
```{r}
fviz_mfa_var(res.mfa, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE,
             geom = c("point", "text"), legend = "bottom")

```


```{r}
fviz_contrib(res.mfa, choice = "quanti.var", axes = 1, top = 20,
             palette = "jco")


```
Graph of individuals

```{r}
# To get the results for individuals, type this:

ind <- get_mfa_ind(res.mfa)
ind

```
To plot individuals, use the function fviz_mfa_ind() [in factoextra]. By default, individuals are colored in blue. However, like variables, it’s also possible to color individuals by their cos2 values:

```{r}
fviz_mfa_ind(res.mfa, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = FALSE)

fviz_mfa_ind(res.mfa, 
             habillage = "Label", # color by groups 
             palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 

```
```{r}

clustering_new_pre_PCA_2

fviz_mfa_ind(res.mfa, 
             habillage = "stimDescription", # color by groups 
             # palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 


fviz_mfa_ind(res.mfa, 
             habillage = "ssid", # color by groups 
             # palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 

```


Aggregate one average per stim


```{r}

library(factoextra)
library(FactoMineR)


colnames(clustering_agg_JASPtest)

clustering_agg_JASP_PCA_2<- clustering_agg_JASPtest [, c(1,27, 2:4)]
colnames(clustering_agg_JASP_PCA_2)

clustering_agg_JASP_PCA_2$stimIAPS2<- as.factor(clustering_agg_JASP_PCA_2$stimIAPS2)

clustering_agg_JASP_PCA_2$stimDescription<- as.factor(clustering_agg_JASP_PCA_2$stimDescription)




res.mfa_agg <- MFA(wine, 
               group = c(2, 5, 3, 10, 9, 2), 
               type = c("n", "s", "s", "s", "s", "s"),
               name.group = c("origin","odor","visual",
                              "odor.after.shaking", "taste","overall"),
               num.group.sup = c(1, 6),
               graph = FALSE)


colnames(clustering_agg_JASP_PCA_2)
res.mfa_agg <- MFA(clustering_agg_JASP_PCA_2, 
               group = c(2, 1, 1, 1), 
               type = c("n", "s", "s", "s"),
               name.group = c("stim_desc","HR","pupil","SCR"),
               num.group.sup = c(1,2),
               graph = TRUE)

print(res.mfa_agg)




```
```{r}
library("factoextra")
eig.val_agg <- get_eigenvalue(res.mfa_agg)
head(eig.val_agg)


```

the function fviz_eig() or fviz_screeplot() [factoextra package] can be used to draw the scree plot:
```{r}
fviz_screeplot(res.mfa_agg)

```

The function get_mfa_var() [in factoextra] is used to extract the results for groups of variables. This function returns a list containing the coordinates, the cos2 and the contribution of groups, as well as, the

```{r}

group_agg <- get_mfa_var(res.mfa_agg, "group")
group_agg

```

The different components can be accessed as follow:
```{r}
# Coordinates of groups
head(group_agg$coord)
# Cos2: quality of representation on the factore map
head(group_agg$cos2)
# Contributions to the  dimensions
head(group_agg$contrib)

```

To plot the groups of variables, type this:

```{r}
fviz_mfa_var(res.mfa_agg, "group")

```


red color = active groups of variables
green color = supplementary groups of variables
The plot above illustrates the correlation between groups and dimensions. The coordinates of the four active groups on the first dimension are almost identical. This means that they contribute similarly to the first dimension. Concerning the second dimension, the two groups - odor and odor.after.shake - have the highest coordinates indicating a highest contribution to the second dimension.

To draw a bar plot of groups contribution to the dimensions, use the function fviz_contrib():
```{r}
# Contribution to the first dimension
fviz_contrib(res.mfa_agg, "group", axes = 1)
# Contribution to the second dimension
fviz_contrib(res.mfa_agg, "group", axes = 2)

```
Quantitative variables
The function get_mfa_var() [in factoextra] is used to extract the results for quantitative variables. This function returns a list containing the coordinates, the cos2 and the contribution of variables:
```{r}
quanti.var_agg <- get_mfa_var(res.mfa_agg, "quanti.var")
quanti.var_agg

```

```{r}
# Coordinates
head(quanti.var_agg$coord)
# Cos2: quality on the factore map
head(quanti.var_agg$cos2)
# Contributions to the dimensions
head(quanti.var_agg$contrib)

```
Correlation between quantitative variables and dimensions. The R code below plots quantitative variables colored by groups. The argument palette is used to change group colors (see ?ggpubr::ggpar for more information about palette). Supplementary quantitative variables are in dashed arrow and violet color. We use repel = TRUE, to avoid text overlapping.

```{r}
fviz_mfa_var(res.mfa_agg, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE)

```

To make the plot more readable, we can use geom = c(“point”, “text”) instead of geom = c(“arrow”, “text”). We’ll change also the legend position from “right” to “bottom”, using the argument legend = “bottom”:
```{r}
fviz_mfa_var(res.mfa_agg, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE,
             geom = c("point", "text"), legend = "bottom")

```


```{r}
fviz_contrib(res.mfa_agg, choice = "quanti.var", axes = 1, top = 20,
             palette = "jco")
fviz_contrib(res.mfa_agg, choice = "quanti.var", axes = 2, top = 20,
             palette = "jco")

```
Graph of individuals

```{r}
# To get the results for individuals, type this:

ind_agg <- get_mfa_ind(res.mfa_agg)
ind_agg

```
To plot individuals, use the function fviz_mfa_ind() [in factoextra]. By default, individuals are colored in blue. However, like variables, it’s also possible to color individuals by their cos2 values:

```{r}
fviz_mfa_ind(res.mfa_agg, col.ind = "cos2", 
             # gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)
clust2_dataset$stimDescription
pp_stim
fviz_mfa_ind(res.mfa_agg, 
             habillage = "stimDescription", # color by groups 
             palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 

```


```{r}

clustering_new_pre_PCA_2

fviz_mfa_ind(res.mfa_agg, 
             habillage = "stimIAPS2", # color by groups 
             # palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 



```

Graph of partial individuals
The results for individuals obtained from the analysis performed with a single group are named partial individuals. In other words, an individual considered from the point of view of a single group is called partial individual.

In the default fviz_mfa_ind() plot, for a given individual, the point corresponds to the mean individual or the center of gravity of the partial points of the individual. That is, the individual viewed by all groups of variables.

For a given individual, there are as many partial points as groups of variables.

The graph of partial individuals represents each wine viewed by each group and its barycenter. To plot the partial points of all individuals, type this:

```{r}
fviz_mfa_ind(res.mfa_agg, partial = "all") 
# If you want to visualize partial points for wines of interest, let say c(“1DAM”, “1VAU”, “2ING”), use this:

fviz_mfa_ind(res.mfa, partial = c("1DAM", "1VAU", "2ING")) 

```


Graph of partial axes
The graph of partial axes shows the relationship between the principal axes of the MFA and the ones obtained from analyzing each group using either a PCA (for groups of continuous variables) or a MCA (for qualitative variables).

```{r}
fviz_mfa_axes(res.mfa_agg)

```


```{r}
data(wine)
View(wine)

View(clustering_new_pre_PCA_2)

```


colnames

```{r}
db_forPCA
colnames(db_forPCA)
library(tidyverse)
data3_forPCA_withar
all.data3_forPCA_withar$TAS_split<- if_else(all.data3_forPCA_withar$TAS > 
                                          median(all.data3_forPCA_withar$TAS, na.rm = TRUE), "High", "Low")
colnames(all.data3_forPCA_withar)
db_forPCA_MFA<- all.data3_forPCA_withar[, c(1,228, 4:171)]

colnames(db_forPCA_MFA)


db_forPCA_MFA

db_forPCA_MFA$ssid<- as.factor(db_forPCA_MFA$ssid)


colnames(db_forPCA_MFA)

db_forPCA_MFA$arousal_9561SickKitty<- NULL
res.mfa_dcast <- MFA(db_forPCA_MFA, 
               group = c(2, 56, 56, 56), 
               type = c("n", "s", "s", "s"),
               name.group = c("pp_gr","pupil","HR","SCR"),
               num.group.sup = c(1,2),
               graph = TRUE)

print(res.mfa_dcast)




```




here



```{r}
library("factoextra")
# res.mfa_dcast <- get_eigenvalue(res.mfa_dcast)
# head(res.mfa_dcast)


```

the function fviz_eig() or fviz_screeplot() [factoextra package] can be used to draw the scree plot:
```{r}
fviz_screeplot(res.mfa_dcast)

```

The function get_mfa_var() [in factoextra] is used to extract the results for groups of variables. This function returns a list containing the coordinates, the cos2 and the contribution of groups, as well as, the

```{r}

group_dcast <- get_mfa_var(res.mfa_dcast, "group")
group_dcast

```

The different components can be accessed as follow:
```{r}
# Coordinates of groups
head(group_dcast$coord)
# Cos2: quality of representation on the factore map
head(group_dcast$cos2)
# Contributions to the  dimensions
head(group_dcast$contrib)

```

To plot the groups of variables, type this:

```{r}
fviz_mfa_var(res.mfa_dcast, "group")

```


red color = active groups of variables
green color = supplementary groups of variables
The plot above illustrates the correlation between groups and dimensions. The coordinates of the four active groups on the first dimension are almost identical. This means that they contribute similarly to the first dimension. Concerning the second dimension, the two groups - odor and odor.after.shake - have the highest coordinates indicating a highest contribution to the second dimension.

To draw a bar plot of groups contribution to the dimensions, use the function fviz_contrib():
```{r}
# Contribution to the first dimension
fviz_contrib(res.mfa_dcast, "group", axes = 1)
# Contribution to the second dimension
fviz_contrib(res.mfa_dcast, "group", axes = 2)

```
Quantitative variables
The function get_mfa_var() [in factoextra] is used to extract the results for quantitative variables. This function returns a list containing the coordinates, the cos2 and the contribution of variables:
```{r}
quanti.var_dcast <- get_mfa_var(res.mfa_dcast, "quanti.var")
quanti.var_dcast

```

```{r}
# Coordinates
head(quanti.var_dcast$coord)
# Cos2: quality on the factore map
head(quanti.var_dcast$cos2)
# Contributions to the dimensions
head(quanti.var_dcast$contrib)

```
Correlation between quantitative variables and dimensions. The R code below plots quantitative variables colored by groups. The argument palette is used to change group colors (see ?ggpubr::ggpar for more information about palette). Supplementary quantitative variables are in dashed arrow and violet color. We use repel = TRUE, to avoid text overlapping.

```{r}
fviz_mfa_var(res.mfa_dcast, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE)

```

To make the plot more readable, we can use geom = c(“point”, “text”) instead of geom = c(“arrow”, “text”). We’ll change also the legend position from “right” to “bottom”, using the argument legend = “bottom”:
```{r}
fviz_mfa_var(res.mfa_dcast, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE,
             geom = c("point", "text"), legend = "bottom")

```


```{r}
fviz_contrib(res.mfa_dcast, choice = "quanti.var", axes = 1, top = 20,
             palette = "jco")
fviz_contrib(res.mfa_agg, choice = "quanti.var", axes = 2, top = 20,
             palette = "jco")

```
Graph of individuals

```{r}
# To get the results for individuals, type this:

ind_dcast <- get_mfa_ind(res.mfa_dcast)
ind_dcast

```
To plot individuals, use the function fviz_mfa_ind() [in factoextra]. By default, individuals are colored in blue. However, like variables, it’s also possible to color individuals by their cos2 values:

```{r}
fviz_mfa_ind(res.mfa_dcast, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)
clust2_dataset$stimDescription
pp_stim
fviz_mfa_ind(res.mfa_dcast, 
             habillage = "TAS_split", # color by groups 
             palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 

```


```{r}

clustering_new_pre_PCA_2

fviz_mfa_ind(res.mfa_dcast, 
             habillage = "stimIAPS2", # color by groups 
             # palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 



```

Graph of partial individuals
The results for individuals obtained from the analysis performed with a single group are named partial individuals. In other words, an individual considered from the point of view of a single group is called partial individual.

In the default fviz_mfa_ind() plot, for a given individual, the point corresponds to the mean individual or the center of gravity of the partial points of the individual. That is, the individual viewed by all groups of variables.

For a given individual, there are as many partial points as groups of variables.

The graph of partial individuals represents each wine viewed by each group and its barycenter. To plot the partial points of all individuals, type this:

```{r}
fviz_mfa_ind(res.mfa_dcast, partial = "all") 
# If you want to visualize partial points for wines of interest, let say c(“1DAM”, “1VAU”, “2ING”), use this:


```


Graph of partial axes
The graph of partial axes shows the relationship between the principal axes of the MFA and the ones obtained from analyzing each group using either a PCA (for groups of continuous variables) or a MCA (for qualitative variables).

```{r}
fviz_mfa_axes(res.mfa_dcast)

```

<!-- neg, neutra positive -->





```{r}
data(wine)
View(wine)

View(clustering_new_pre_PCA_2)
?cut
clustering_new_pre_PCA_2$valence_split<- cut(clustering_new_pre_PCA_2$valence, 3,
                                             labels = c("neg", "mid", "positive"))



clustering_new_pre_PCA_2_agg_by_val<- clustering_new_pre_PCA_2%>%
  group_by(ssid,valence_split)%>%
  summarise_if(is.numeric, mean, na.rm = TRUE)


View(clustering_new_pre_PCA_2_agg_by_val)

colnames(clustering_new_pre_PCA_2_agg_by_val)
clustering_new_pre_PCA_2_agg_by_val_sel<- clustering_new_pre_PCA_2_agg_by_val[, c(1:7)]

# dcast
library(data.table)
clustering_new_pre_PCA_2_agg_by_val_sel_dcast<- data.table::dcast(setDT(clustering_new_pre_PCA_2_agg_by_val_sel), 
                    ssid ~ valence_split, value.var = c('pup_basCor',
                'Bio_Mean_HR_dif', 'log_BIO_CDA.PhasicMax', "arousal", "valence"))

clustering_new_pre_PCA_2_agg_by_val_sel_dcast

clustering_new_pre_PCA_2_agg_by_val_sel_dcast$pup_basCor_NA<- NULL

clustering_new_pre_PCA_2_agg_by_val_sel_dcast$Bio_Mean_HR_dif_NA<- NULL
clustering_new_pre_PCA_2_agg_by_val_sel_dcast$log_BIO_CDA.PhasicMax_NA<- NULL

clustering_new_pre_PCA_2_agg_by_val_sel_dcast$valence_NA<- NULL
clustering_new_pre_PCA_2_agg_by_val_sel_dcast$arousal_NA<- NULL
clustering_new_pre_PCA_2_agg_by_val_sel_dcast
View(clustering_new_pre_PCA_2_agg_by_val_sel_dcast)

namesrepl<- colnames(clustering_new_pre_PCA_2_agg_by_val_sel_dcast)

namesrepl<- c("ssid", "p_neg", "p_mid" ,"p_pos", "HR_neg" , "HR_mid",
                  "HR_pos","SCR_neg", "SCR_mid", "SCR_pos", "ar_neg","ar_mid", "ar_pos",
              "vl_neg","vl_mid", "vl_pos")

clustering_new_pre_PCA_2_agg_by_val_sel_dcast2<- clustering_new_pre_PCA_2_agg_by_val_sel_dcast
names(clustering_new_pre_PCA_2_agg_by_val_sel_dcast2)<- namesrepl


```

MFA agg by val


```{r}
colnames(clustering_new_pre_PCA_2_agg_by_val_sel_dcast2)
res.mfa_agg_byval <- MFA(clustering_new_pre_PCA_2_agg_by_val_sel_dcast2, 
               group = c(1, 3, 3, 3), 
               type = c("n", "s", "s", "s"),
               name.group = c("ssid","pupil","HR","SCR"),
               num.group.sup = c(1),
               graph = TRUE)

print(res.mfa_agg_byval)


clustering_new_pre_PCA_2_agg_by_val_sel_dcast2$pcscoremaybe <- res.mfa_agg_byval[["global.pca"]][["ind"]][["cos2"]][,1]

clustering_new_pre_PCA_2_agg_by_val_sel_dcast2$ar<- (clustering_new_pre_PCA_2_agg_by_val_sel_dcast2$ar_neg+clustering_new_pre_PCA_2_agg_by_val_sel_dcast2$ar_mid+
  clustering_new_pre_PCA_2_agg_by_val_sel_dcast2$ar_pos)/3

# cor.test(res.mfa_agg_byval[["global.pca"]][["ind"]][["cos2"]][,3],
#          clustering_new_pre_PCA_2_agg_by_val_sel_dcast2$ar)

```



```{r}
library("factoextra")
eif_vyval <- get_eigenvalue(res.mfa_agg_byval)
head(eif_vyval)


```

the function fviz_eig() or fviz_screeplot() [factoextra package] can be used to draw the scree plot:
```{r}
fviz_screeplot(res.mfa_agg_byval)

```

The function get_mfa_var() [in factoextra] is used to extract the results for groups of variables. This function returns a list containing the coordinates, the cos2 and the contribution of groups, as well as, the

```{r}

group_vybal <- get_mfa_var(res.mfa_agg_byval, "group")
group_vybal

```

The different components can be accessed as follow:
```{r}
# Coordinates of groups
head(group_vybal$coord)
# Cos2: quality of representation on the factore map
head(group_vybal$cos2)
# Contributions to the  dimensions
head(group_vybal$contrib)

```

To plot the groups of variables, type this:

```{r}
fviz_mfa_var(res.mfa_agg_byval, "group")

```


red color = active groups of variables
green color = supplementary groups of variables
The plot above illustrates the correlation between groups and dimensions. The coordinates of the four active groups on the first dimension are almost identical. This means that they contribute similarly to the first dimension. Concerning the second dimension, the two groups - odor and odor.after.shake - have the highest coordinates indicating a highest contribution to the second dimension.

To draw a bar plot of groups contribution to the dimensions, use the function fviz_contrib():
```{r}
# Contribution to the first dimension
fviz_contrib(res.mfa_agg_byval, "group", axes = 1)
# Contribution to the second dimension
fviz_contrib(res.mfa_agg_byval, "group", axes = 2)

```
Quantitative variables
The function get_mfa_var() [in factoextra] is used to extract the results for quantitative variables. This function returns a list containing the coordinates, the cos2 and the contribution of variables:
```{r}
quanti.var_agg_by_val <- get_mfa_var(res.mfa_agg_byval, "quanti.var")
quanti.var_agg_by_val

```

```{r}
# Coordinates
head(quanti.var_agg_by_val$coord)
# Cos2: quality on the factore map
head(quanti.var_agg_by_val$cos2)
# Contributions to the dimensions
head(quanti.var_agg_by_val$contrib)

```
Correlation between quantitative variables and dimensions. The R code below plots quantitative variables colored by groups. The argument palette is used to change group colors (see ?ggpubr::ggpar for more information about palette). Supplementary quantitative variables are in dashed arrow and violet color. We use repel = TRUE, to avoid text overlapping.

```{r}
fviz_mfa_var(res.mfa_agg_byval, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE)


```



Correlation between quantitative variables and dimensions. The R code below plots quantitative variables colored by groups. The argument palette is used to change group colors (see ?ggpubr::ggpar for more information about palette). Supplementary quantitative variables are in dashed arrow and violet color. We use repel = TRUE, to avoid text overlapping.

```{r}
fviz_mfa_var(res.mfa_dcast, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE)

```

To make the plot more readable, we can use geom = c(“point”, “text”) instead of geom = c(“arrow”, “text”). We’ll change also the legend position from “right” to “bottom”, using the argument legend = “bottom”:
```{r}
fviz_mfa_var(res.mfa_agg_byval, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE,
             geom = c("point", "text"), legend = "bottom")

```


```{r}
fviz_contrib(res.mfa_agg_byval, choice = "quanti.var", axes = 1, top = 20,
             palette = "jco")
fviz_contrib(res.mfa_agg_byval, choice = "quanti.var", axes = 2, top = 20,
             palette = "jco")

```
Graph of individuals

```{r}
# To get the results for individuals, type this:

ind_agg_byval <- get_mfa_ind(res.mfa_agg_byval)
ind_agg_byval

```
To plot individuals, use the function fviz_mfa_ind() [in factoextra]. By default, individuals are colored in blue. However, like variables, it’s also possible to color individuals by their cos2 values:

```{r}
fviz_mfa_ind(res.mfa_agg_byval, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)

fviz_mfa_ind(res.mfa_agg_byval, 
             habillage = "ssid", # color by groups
             # palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 

```


```{r}

clustering_new_pre_PCA_2

fviz_mfa_ind(res.mfa_agg_byval, 
             # habillage = "stimIAPS2", # color by groups 
             # palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 



```

Graph of partial individuals
The results for individuals obtained from the analysis performed with a single group are named partial individuals. In other words, an individual considered from the point of view of a single group is called partial individual.

In the default fviz_mfa_ind() plot, for a given individual, the point corresponds to the mean individual or the center of gravity of the partial points of the individual. That is, the individual viewed by all groups of variables.

For a given individual, there are as many partial points as groups of variables.

The graph of partial individuals represents each wine viewed by each group and its barycenter. To plot the partial points of all individuals, type this:

```{r}
fviz_mfa_ind(res.mfa_agg_byval, partial = "all") 
# If you want to visualize partial points for wines of interest, let say c(“1DAM”, “1VAU”, “2ING”), use this:


```


Graph of partial axes
The graph of partial axes shows the relationship between the principal axes of the MFA and the ones obtained from analyzing each group using either a PCA (for groups of continuous variables) or a MCA (for qualitative variables).

```{r}
fviz_mfa_axes(res.mfa_agg_byval)

```


with valence
clustering_new_pre_PCA_2_agg_by_val_sel_dcast



```{r}

colnames(clustering_new_pre_PCA_2_agg_by_val_sel_dcast2)
res.mfa_agg_byval2 <- MFA(clustering_new_pre_PCA_2_agg_by_val_sel_dcast2, 
               group = c(1, 3, 3, 3,3,3), 
               type = c("n", "s", "s", "s","s", "s"),
               name.group = c("ssid","pupil","HR","SCR", "AR", "VL"),
               num.group.sup = c(1),
               graph = TRUE)

print(res.mfa_agg_byval2)


```



```{r}
library("factoextra")
eif_vyval2 <- get_eigenvalue(res.mfa_agg_byval2)
head(eif_vyval2)


```

the function fviz_eig() or fviz_screeplot() [factoextra package] can be used to draw the scree plot:
```{r}
fviz_screeplot(res.mfa_agg_byval2)

```

The function get_mfa_var() [in factoextra] is used to extract the results for groups of variables. This function returns a list containing the coordinates, the cos2 and the contribution of groups, as well as, the

```{r}

group_vybal2 <- get_mfa_var(res.mfa_agg_byval2, "group")
group_vybal2

```

The different components can be accessed as follow:
```{r}
# Coordinates of groups
head(group_vybal2$coord)
# Cos2: quality of representation on the factore map
head(group_vybal2$cos2)
# Contributions to the  dimensions
head(group_vybal2$contrib)

```

To plot the groups of variables, type this:

```{r}
fviz_mfa_var(res.mfa_agg_byval2, "group")

```


red color = active groups of variables
green color = supplementary groups of variables
The plot above illustrates the correlation between groups and dimensions. The coordinates of the four active groups on the first dimension are almost identical. This means that they contribute similarly to the first dimension. Concerning the second dimension, the two groups - odor and odor.after.shake - have the highest coordinates indicating a highest contribution to the second dimension.

To draw a bar plot of groups contribution to the dimensions, use the function fviz_contrib():
```{r}
# Contribution to the first dimension
fviz_contrib(res.mfa_agg_byval2, "group", axes = 1)
# Contribution to the second dimension
fviz_contrib(res.mfa_agg_byval2, "group", axes = 2)

```
Quantitative variables
The function get_mfa_var() [in factoextra] is used to extract the results for quantitative variables. This function returns a list containing the coordinates, the cos2 and the contribution of variables:
```{r}
quanti.var_agg_by_val2 <- get_mfa_var(res.mfa_agg_byval2, "quanti.var")
quanti.var_agg_by_val2

```

```{r}
# Coordinates
head(quanti.var_agg_by_val2$coord)
# Cos2: quality on the factore map
head(quanti.var_agg_by_val2$cos2)
# Contributions to the dimensions
head(quanti.var_agg_by_val2$contrib)

```
Correlation between quantitative variables and dimensions. The R code below plots quantitative variables colored by groups. The argument palette is used to change group colors (see ?ggpubr::ggpar for more information about palette). Supplementary quantitative variables are in dashed arrow and violet color. We use repel = TRUE, to avoid text overlapping.

```{r}
fviz_mfa_var(res.mfa_agg_byval2, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE)


```



Correlation between quantitative variables and dimensions. The R code below plots quantitative variables colored by groups. The argument palette is used to change group colors (see ?ggpubr::ggpar for more information about palette). Supplementary quantitative variables are in dashed arrow and violet color. We use repel = TRUE, to avoid text overlapping.

```{r}
fviz_mfa_var(res.mfa_agg_byval2, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE)

```

To make the plot more readable, we can use geom = c(“point”, “text”) instead of geom = c(“arrow”, “text”). We’ll change also the legend position from “right” to “bottom”, using the argument legend = “bottom”:
```{r}
fviz_mfa_var(res.mfa_agg_byval2, "quanti.var", palette = "jco", 
             col.var.sup = "violet", repel = TRUE,
             geom = c("point", "text"), legend = "bottom")

```


```{r}
fviz_contrib(res.mfa_agg_byval2, choice = "quanti.var", axes = 1, top = 20,
             palette = "jco")
fviz_contrib(res.mfa_agg_byval, choice = "quanti.var", axes = 2, top = 20,
             palette = "jco")

```
Graph of individuals

```{r}
# To get the results for individuals, type this:

ind_agg_byval2 <- get_mfa_ind(res.mfa_agg_byval2)
ind_agg_byval2

```
To plot individuals, use the function fviz_mfa_ind() [in factoextra]. By default, individuals are colored in blue. However, like variables, it’s also possible to color individuals by their cos2 values:

```{r}
fviz_mfa_ind(res.mfa_agg_byval2, col.ind = "cos2", 
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)

fviz_mfa_ind(res.mfa_agg_byval2, 
             habillage = "ssid", # color by groups
             # palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 

```


```{r}

clustering_new_pre_PCA_2

fviz_mfa_ind(res.mfa_agg_byval2, 
             # habillage = "stimIAPS2", # color by groups 
             # palette = c("#00AFBB", "#E7B800", "#FC4E07"),
             addEllipses = TRUE, ellipse.type = "confidence", 
             repel = TRUE # Avoid text overlapping
             ) 



```

Graph of partial individuals
The results for individuals obtained from the analysis performed with a single group are named partial individuals. In other words, an individual considered from the point of view of a single group is called partial individual.

In the default fviz_mfa_ind() plot, for a given individual, the point corresponds to the mean individual or the center of gravity of the partial points of the individual. That is, the individual viewed by all groups of variables.

For a given individual, there are as many partial points as groups of variables.

The graph of partial individuals represents each wine viewed by each group and its barycenter. To plot the partial points of all individuals, type this:

```{r}
fviz_mfa_ind(res.mfa_agg_byval2, partial = "all") 
# If you want to visualize partial points for wines of interest, let say c(“1DAM”, “1VAU”, “2ING”), use this:


```


Graph of partial axes
The graph of partial axes shows the relationship between the principal axes of the MFA and the ones obtained from analyzing each group using either a PCA (for groups of continuous variables) or a MCA (for qualitative variables).

```{r}
fviz_mfa_axes(res.mfa_agg_byval2)
fviz_mfa_axes()

```


Mutual information

```{r}
install.packages("infotheo")
library(infotheo)

mutinformation(X, Y, method="emp")
?mutinformation
mutinformation(clustering_new_pre_PCA_2$arousal, clustering_new_pre_PCA_2$pup_basCor, 
               method="mm")

install.packages("entropy")

entropy::mi.plugin(clustering_new_pre_PCA_2[,c(3,6)])
```
